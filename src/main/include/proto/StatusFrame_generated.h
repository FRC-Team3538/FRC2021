// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_
#define FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_

#include "flatbuffers/flatbuffers.h"

namespace rj {

struct InitializeStatusFrame;
struct InitializeStatusFrameBuilder;

struct REVCANEncoder;

struct REVCANAnalog;

struct REVPIDController;

struct REVCANDigitalInput;

struct REVMotorStatusFrame;
struct REVMotorStatusFrameBuilder;

struct RawColor;

struct REVColorSensorStatusFrame;
struct REVColorSensorStatusFrameBuilder;

struct BoardYawAxis;

struct NavXStatusFrame;
struct NavXStatusFrameBuilder;

struct ADIS16470StatusFrame;
struct ADIS16470StatusFrameBuilder;

struct CTREMotorStatusFrame;
struct CTREMotorStatusFrameBuilder;

struct PDPStatusFrame;
struct PDPStatusFrameBuilder;

struct PCMStatusFrame;
struct PCMStatusFrameBuilder;

struct WPIDigitalInput;
struct WPIDigitalInputBuilder;

struct WPIEncoder;
struct WPIEncoderBuilder;

struct WPIDutyCycleEncoder;
struct WPIDutyCycleEncoderBuilder;

struct StatusFrameHolder;
struct StatusFrameHolderBuilder;

enum StatusFrame : uint8_t {
  StatusFrame_NONE = 0,
  StatusFrame_CTREMotorStatusFrame = 1,
  StatusFrame_PDPStatusFrame = 2,
  StatusFrame_PCMStatusFrame = 3,
  StatusFrame_InitializeStatusFrame = 4,
  StatusFrame_REVMotorStatusFrame = 5,
  StatusFrame_REVColorSensorStatusFrame = 6,
  StatusFrame_NavXStatusFrame = 7,
  StatusFrame_ADIS16470StatusFrame = 8,
  StatusFrame_WPIDigitalInput = 9,
  StatusFrame_WPIEncoder = 10,
  StatusFrame_WPIDutyCycleEncoder = 11,
  StatusFrame_MIN = StatusFrame_NONE,
  StatusFrame_MAX = StatusFrame_WPIDutyCycleEncoder
};

inline const StatusFrame (&EnumValuesStatusFrame())[12] {
  static const StatusFrame values[] = {
    StatusFrame_NONE,
    StatusFrame_CTREMotorStatusFrame,
    StatusFrame_PDPStatusFrame,
    StatusFrame_PCMStatusFrame,
    StatusFrame_InitializeStatusFrame,
    StatusFrame_REVMotorStatusFrame,
    StatusFrame_REVColorSensorStatusFrame,
    StatusFrame_NavXStatusFrame,
    StatusFrame_ADIS16470StatusFrame,
    StatusFrame_WPIDigitalInput,
    StatusFrame_WPIEncoder,
    StatusFrame_WPIDutyCycleEncoder
  };
  return values;
}

inline const char * const *EnumNamesStatusFrame() {
  static const char * const names[13] = {
    "NONE",
    "CTREMotorStatusFrame",
    "PDPStatusFrame",
    "PCMStatusFrame",
    "InitializeStatusFrame",
    "REVMotorStatusFrame",
    "REVColorSensorStatusFrame",
    "NavXStatusFrame",
    "ADIS16470StatusFrame",
    "WPIDigitalInput",
    "WPIEncoder",
    "WPIDutyCycleEncoder",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatusFrame(StatusFrame e) {
  if (flatbuffers::IsOutRange(e, StatusFrame_NONE, StatusFrame_WPIDutyCycleEncoder)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatusFrame()[index];
}

template<typename T> struct StatusFrameTraits {
  static const StatusFrame enum_value = StatusFrame_NONE;
};

template<> struct StatusFrameTraits<rj::CTREMotorStatusFrame> {
  static const StatusFrame enum_value = StatusFrame_CTREMotorStatusFrame;
};

template<> struct StatusFrameTraits<rj::PDPStatusFrame> {
  static const StatusFrame enum_value = StatusFrame_PDPStatusFrame;
};

template<> struct StatusFrameTraits<rj::PCMStatusFrame> {
  static const StatusFrame enum_value = StatusFrame_PCMStatusFrame;
};

template<> struct StatusFrameTraits<rj::InitializeStatusFrame> {
  static const StatusFrame enum_value = StatusFrame_InitializeStatusFrame;
};

template<> struct StatusFrameTraits<rj::REVMotorStatusFrame> {
  static const StatusFrame enum_value = StatusFrame_REVMotorStatusFrame;
};

template<> struct StatusFrameTraits<rj::REVColorSensorStatusFrame> {
  static const StatusFrame enum_value = StatusFrame_REVColorSensorStatusFrame;
};

template<> struct StatusFrameTraits<rj::NavXStatusFrame> {
  static const StatusFrame enum_value = StatusFrame_NavXStatusFrame;
};

template<> struct StatusFrameTraits<rj::ADIS16470StatusFrame> {
  static const StatusFrame enum_value = StatusFrame_ADIS16470StatusFrame;
};

template<> struct StatusFrameTraits<rj::WPIDigitalInput> {
  static const StatusFrame enum_value = StatusFrame_WPIDigitalInput;
};

template<> struct StatusFrameTraits<rj::WPIEncoder> {
  static const StatusFrame enum_value = StatusFrame_WPIEncoder;
};

template<> struct StatusFrameTraits<rj::WPIDutyCycleEncoder> {
  static const StatusFrame enum_value = StatusFrame_WPIDutyCycleEncoder;
};

bool VerifyStatusFrame(flatbuffers::Verifier &verifier, const void *obj, StatusFrame type);
bool VerifyStatusFrameVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) REVCANEncoder FLATBUFFERS_FINAL_CLASS {
 private:
  double position_;
  double velocity_;
  double positionConversionFactor_;
  double velocityConversionFactor_;
  uint32_t averageDepth_;
  uint32_t measurementPeriod_;
  uint32_t countsPerRevolution_;
  uint8_t inverted_;
  uint8_t lastError_;
  int16_t padding0__;

 public:
  REVCANEncoder()
      : position_(0),
        velocity_(0),
        positionConversionFactor_(0),
        velocityConversionFactor_(0),
        averageDepth_(0),
        measurementPeriod_(0),
        countsPerRevolution_(0),
        inverted_(0),
        lastError_(0),
        padding0__(0) {
    (void)padding0__;
  }
  REVCANEncoder(double _position, double _velocity, double _positionConversionFactor, double _velocityConversionFactor, uint32_t _averageDepth, uint32_t _measurementPeriod, uint32_t _countsPerRevolution, bool _inverted, uint8_t _lastError)
      : position_(flatbuffers::EndianScalar(_position)),
        velocity_(flatbuffers::EndianScalar(_velocity)),
        positionConversionFactor_(flatbuffers::EndianScalar(_positionConversionFactor)),
        velocityConversionFactor_(flatbuffers::EndianScalar(_velocityConversionFactor)),
        averageDepth_(flatbuffers::EndianScalar(_averageDepth)),
        measurementPeriod_(flatbuffers::EndianScalar(_measurementPeriod)),
        countsPerRevolution_(flatbuffers::EndianScalar(_countsPerRevolution)),
        inverted_(flatbuffers::EndianScalar(static_cast<uint8_t>(_inverted))),
        lastError_(flatbuffers::EndianScalar(_lastError)),
        padding0__(0) {
    (void)padding0__;
  }
  double position() const {
    return flatbuffers::EndianScalar(position_);
  }
  double velocity() const {
    return flatbuffers::EndianScalar(velocity_);
  }
  double positionConversionFactor() const {
    return flatbuffers::EndianScalar(positionConversionFactor_);
  }
  double velocityConversionFactor() const {
    return flatbuffers::EndianScalar(velocityConversionFactor_);
  }
  uint32_t averageDepth() const {
    return flatbuffers::EndianScalar(averageDepth_);
  }
  uint32_t measurementPeriod() const {
    return flatbuffers::EndianScalar(measurementPeriod_);
  }
  uint32_t countsPerRevolution() const {
    return flatbuffers::EndianScalar(countsPerRevolution_);
  }
  bool inverted() const {
    return flatbuffers::EndianScalar(inverted_) != 0;
  }
  uint8_t lastError() const {
    return flatbuffers::EndianScalar(lastError_);
  }
};
FLATBUFFERS_STRUCT_END(REVCANEncoder, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) REVCANAnalog FLATBUFFERS_FINAL_CLASS {
 private:
  double voltage_;
  double position_;
  double velocity_;
  double positionConversionFactor_;
  double velocityConversaionFactor_;
  uint32_t averageDepth_;
  uint32_t measurementPeriod_;
  uint8_t inverted_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  REVCANAnalog()
      : voltage_(0),
        position_(0),
        velocity_(0),
        positionConversionFactor_(0),
        velocityConversaionFactor_(0),
        averageDepth_(0),
        measurementPeriod_(0),
        inverted_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  REVCANAnalog(double _voltage, double _position, double _velocity, double _positionConversionFactor, double _velocityConversaionFactor, uint32_t _averageDepth, uint32_t _measurementPeriod, bool _inverted)
      : voltage_(flatbuffers::EndianScalar(_voltage)),
        position_(flatbuffers::EndianScalar(_position)),
        velocity_(flatbuffers::EndianScalar(_velocity)),
        positionConversionFactor_(flatbuffers::EndianScalar(_positionConversionFactor)),
        velocityConversaionFactor_(flatbuffers::EndianScalar(_velocityConversaionFactor)),
        averageDepth_(flatbuffers::EndianScalar(_averageDepth)),
        measurementPeriod_(flatbuffers::EndianScalar(_measurementPeriod)),
        inverted_(flatbuffers::EndianScalar(static_cast<uint8_t>(_inverted))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  double voltage() const {
    return flatbuffers::EndianScalar(voltage_);
  }
  double position() const {
    return flatbuffers::EndianScalar(position_);
  }
  double velocity() const {
    return flatbuffers::EndianScalar(velocity_);
  }
  double positionConversionFactor() const {
    return flatbuffers::EndianScalar(positionConversionFactor_);
  }
  double velocityConversaionFactor() const {
    return flatbuffers::EndianScalar(velocityConversaionFactor_);
  }
  uint32_t averageDepth() const {
    return flatbuffers::EndianScalar(averageDepth_);
  }
  uint32_t measurementPeriod() const {
    return flatbuffers::EndianScalar(measurementPeriod_);
  }
  bool inverted() const {
    return flatbuffers::EndianScalar(inverted_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(REVCANAnalog, 56);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) REVPIDController FLATBUFFERS_FINAL_CLASS {
 private:
  double p_;
  double i_;
  double d_;
  double dFilter_;
  double ff_;
  double iZone_;
  double outputMin_;
  double outputMax_;
  double smartMotionMaxVelocity_;
  double smartMotionMaxAccel_;
  double smartMotionMinOutputVelocity_;
  double smartMotionAllowedClosedLoopError_;
  double iMaxAccum_;
  double iAccum_;

 public:
  REVPIDController()
      : p_(0),
        i_(0),
        d_(0),
        dFilter_(0),
        ff_(0),
        iZone_(0),
        outputMin_(0),
        outputMax_(0),
        smartMotionMaxVelocity_(0),
        smartMotionMaxAccel_(0),
        smartMotionMinOutputVelocity_(0),
        smartMotionAllowedClosedLoopError_(0),
        iMaxAccum_(0),
        iAccum_(0) {
  }
  REVPIDController(double _p, double _i, double _d, double _dFilter, double _ff, double _iZone, double _outputMin, double _outputMax, double _smartMotionMaxVelocity, double _smartMotionMaxAccel, double _smartMotionMinOutputVelocity, double _smartMotionAllowedClosedLoopError, double _iMaxAccum, double _iAccum)
      : p_(flatbuffers::EndianScalar(_p)),
        i_(flatbuffers::EndianScalar(_i)),
        d_(flatbuffers::EndianScalar(_d)),
        dFilter_(flatbuffers::EndianScalar(_dFilter)),
        ff_(flatbuffers::EndianScalar(_ff)),
        iZone_(flatbuffers::EndianScalar(_iZone)),
        outputMin_(flatbuffers::EndianScalar(_outputMin)),
        outputMax_(flatbuffers::EndianScalar(_outputMax)),
        smartMotionMaxVelocity_(flatbuffers::EndianScalar(_smartMotionMaxVelocity)),
        smartMotionMaxAccel_(flatbuffers::EndianScalar(_smartMotionMaxAccel)),
        smartMotionMinOutputVelocity_(flatbuffers::EndianScalar(_smartMotionMinOutputVelocity)),
        smartMotionAllowedClosedLoopError_(flatbuffers::EndianScalar(_smartMotionAllowedClosedLoopError)),
        iMaxAccum_(flatbuffers::EndianScalar(_iMaxAccum)),
        iAccum_(flatbuffers::EndianScalar(_iAccum)) {
  }
  double p() const {
    return flatbuffers::EndianScalar(p_);
  }
  double i() const {
    return flatbuffers::EndianScalar(i_);
  }
  double d() const {
    return flatbuffers::EndianScalar(d_);
  }
  double dFilter() const {
    return flatbuffers::EndianScalar(dFilter_);
  }
  double ff() const {
    return flatbuffers::EndianScalar(ff_);
  }
  double iZone() const {
    return flatbuffers::EndianScalar(iZone_);
  }
  double outputMin() const {
    return flatbuffers::EndianScalar(outputMin_);
  }
  double outputMax() const {
    return flatbuffers::EndianScalar(outputMax_);
  }
  double smartMotionMaxVelocity() const {
    return flatbuffers::EndianScalar(smartMotionMaxVelocity_);
  }
  double smartMotionMaxAccel() const {
    return flatbuffers::EndianScalar(smartMotionMaxAccel_);
  }
  double smartMotionMinOutputVelocity() const {
    return flatbuffers::EndianScalar(smartMotionMinOutputVelocity_);
  }
  double smartMotionAllowedClosedLoopError() const {
    return flatbuffers::EndianScalar(smartMotionAllowedClosedLoopError_);
  }
  double iMaxAccum() const {
    return flatbuffers::EndianScalar(iMaxAccum_);
  }
  double iAccum() const {
    return flatbuffers::EndianScalar(iAccum_);
  }
};
FLATBUFFERS_STRUCT_END(REVPIDController, 112);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) REVCANDigitalInput FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t value_;
  uint8_t enabled_;

 public:
  REVCANDigitalInput()
      : value_(0),
        enabled_(0) {
  }
  REVCANDigitalInput(bool _value, bool _enabled)
      : value_(flatbuffers::EndianScalar(static_cast<uint8_t>(_value))),
        enabled_(flatbuffers::EndianScalar(static_cast<uint8_t>(_enabled))) {
  }
  bool value() const {
    return flatbuffers::EndianScalar(value_) != 0;
  }
  bool enabled() const {
    return flatbuffers::EndianScalar(enabled_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(REVCANDigitalInput, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RawColor FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t red_;
  uint32_t green_;
  uint32_t blue_;
  uint32_t ir_;

 public:
  RawColor()
      : red_(0),
        green_(0),
        blue_(0),
        ir_(0) {
  }
  RawColor(uint32_t _red, uint32_t _green, uint32_t _blue, uint32_t _ir)
      : red_(flatbuffers::EndianScalar(_red)),
        green_(flatbuffers::EndianScalar(_green)),
        blue_(flatbuffers::EndianScalar(_blue)),
        ir_(flatbuffers::EndianScalar(_ir)) {
  }
  uint32_t red() const {
    return flatbuffers::EndianScalar(red_);
  }
  uint32_t green() const {
    return flatbuffers::EndianScalar(green_);
  }
  uint32_t blue() const {
    return flatbuffers::EndianScalar(blue_);
  }
  uint32_t ir() const {
    return flatbuffers::EndianScalar(ir_);
  }
};
FLATBUFFERS_STRUCT_END(RawColor, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) BoardYawAxis FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t boardAxis_;
  uint8_t up_;

 public:
  BoardYawAxis()
      : boardAxis_(0),
        up_(0) {
  }
  BoardYawAxis(uint8_t _boardAxis, bool _up)
      : boardAxis_(flatbuffers::EndianScalar(_boardAxis)),
        up_(flatbuffers::EndianScalar(static_cast<uint8_t>(_up))) {
  }
  uint8_t boardAxis() const {
    return flatbuffers::EndianScalar(boardAxis_);
  }
  bool up() const {
    return flatbuffers::EndianScalar(up_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(BoardYawAxis, 2);

struct InitializeStatusFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InitializeStatusFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TITLE = 4
  };
  const flatbuffers::String *title() const {
    return GetPointer<const flatbuffers::String *>(VT_TITLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           verifier.EndTable();
  }
};

struct InitializeStatusFrameBuilder {
  typedef InitializeStatusFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_title(flatbuffers::Offset<flatbuffers::String> title) {
    fbb_.AddOffset(InitializeStatusFrame::VT_TITLE, title);
  }
  explicit InitializeStatusFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InitializeStatusFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InitializeStatusFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<InitializeStatusFrame> CreateInitializeStatusFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> title = 0) {
  InitializeStatusFrameBuilder builder_(_fbb);
  builder_.add_title(title);
  return builder_.Finish();
}

inline flatbuffers::Offset<InitializeStatusFrame> CreateInitializeStatusFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *title = nullptr) {
  auto title__ = title ? _fbb.CreateString(title) : 0;
  return rj::CreateInitializeStatusFrame(
      _fbb,
      title__);
}

struct REVMotorStatusFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REVMotorStatusFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRMWAREVERSION = 4,
    VT_FIRMWARESTRING = 6,
    VT_SERIALNUMBER = 8,
    VT_DEVICEID = 10,
    VT_ENCODER = 12,
    VT_ALTENCODER = 14,
    VT_ANALOG = 16,
    VT_PID0 = 18,
    VT_PID1 = 20,
    VT_PID2 = 22,
    VT_PID3 = 24,
    VT_FWDLIMITSWITCH = 26,
    VT_REVLIMITSWITCH = 28,
    VT_IDLEMODE = 30,
    VT_VOLTAGECOMPENSATIONNOMINALVOLTAGE = 32,
    VT_OPENLOOPRAMPRATE = 34,
    VT_CLOSEDLOOPRAMPRATE = 36,
    VT_BUSVOLTAGE = 38,
    VT_APPLIEDOUTPUT = 40,
    VT_OUTPUTCURRENT = 42,
    VT_TEMPERATURE = 44,
    VT_SOFTLIMITFORWARDENABLED = 46,
    VT_SOFTLIMITREVERSEENABLED = 48,
    VT_SOFTLIMITFORWARDVALUE = 50,
    VT_SOFTLIMITREVERSEVALUE = 52,
    VT_LASTERROR = 54
  };
  uint32_t firmwareVersion() const {
    return GetField<uint32_t>(VT_FIRMWAREVERSION, 0);
  }
  const flatbuffers::String *firmwareString() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWARESTRING);
  }
  const flatbuffers::Vector<uint8_t> *serialNumber() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SERIALNUMBER);
  }
  int32_t deviceID() const {
    return GetField<int32_t>(VT_DEVICEID, 0);
  }
  const rj::REVCANEncoder *encoder() const {
    return GetStruct<const rj::REVCANEncoder *>(VT_ENCODER);
  }
  const rj::REVCANEncoder *altEncoder() const {
    return GetStruct<const rj::REVCANEncoder *>(VT_ALTENCODER);
  }
  const rj::REVCANAnalog *analog() const {
    return GetStruct<const rj::REVCANAnalog *>(VT_ANALOG);
  }
  const rj::REVPIDController *pid0() const {
    return GetStruct<const rj::REVPIDController *>(VT_PID0);
  }
  const rj::REVPIDController *pid1() const {
    return GetStruct<const rj::REVPIDController *>(VT_PID1);
  }
  const rj::REVPIDController *pid2() const {
    return GetStruct<const rj::REVPIDController *>(VT_PID2);
  }
  const rj::REVPIDController *pid3() const {
    return GetStruct<const rj::REVPIDController *>(VT_PID3);
  }
  const rj::REVCANDigitalInput *fwdLimitSwitch() const {
    return GetStruct<const rj::REVCANDigitalInput *>(VT_FWDLIMITSWITCH);
  }
  const rj::REVCANDigitalInput *revLimitSwitch() const {
    return GetStruct<const rj::REVCANDigitalInput *>(VT_REVLIMITSWITCH);
  }
  bool idleMode() const {
    return GetField<uint8_t>(VT_IDLEMODE, 0) != 0;
  }
  double voltageCompensationNominalVoltage() const {
    return GetField<double>(VT_VOLTAGECOMPENSATIONNOMINALVOLTAGE, 0.0);
  }
  double openLoopRampRate() const {
    return GetField<double>(VT_OPENLOOPRAMPRATE, 0.0);
  }
  double closedLoopRampRate() const {
    return GetField<double>(VT_CLOSEDLOOPRAMPRATE, 0.0);
  }
  double busVoltage() const {
    return GetField<double>(VT_BUSVOLTAGE, 0.0);
  }
  double appliedOutput() const {
    return GetField<double>(VT_APPLIEDOUTPUT, 0.0);
  }
  double outputCurrent() const {
    return GetField<double>(VT_OUTPUTCURRENT, 0.0);
  }
  double temperature() const {
    return GetField<double>(VT_TEMPERATURE, 0.0);
  }
  bool softLimitForwardEnabled() const {
    return GetField<uint8_t>(VT_SOFTLIMITFORWARDENABLED, 0) != 0;
  }
  bool softLimitReverseEnabled() const {
    return GetField<uint8_t>(VT_SOFTLIMITREVERSEENABLED, 0) != 0;
  }
  double softLimitForwardValue() const {
    return GetField<double>(VT_SOFTLIMITFORWARDVALUE, 0.0);
  }
  double softLimitReverseValue() const {
    return GetField<double>(VT_SOFTLIMITREVERSEVALUE, 0.0);
  }
  uint8_t lastError() const {
    return GetField<uint8_t>(VT_LASTERROR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FIRMWAREVERSION) &&
           VerifyOffset(verifier, VT_FIRMWARESTRING) &&
           verifier.VerifyString(firmwareString()) &&
           VerifyOffset(verifier, VT_SERIALNUMBER) &&
           verifier.VerifyVector(serialNumber()) &&
           VerifyField<int32_t>(verifier, VT_DEVICEID) &&
           VerifyField<rj::REVCANEncoder>(verifier, VT_ENCODER) &&
           VerifyField<rj::REVCANEncoder>(verifier, VT_ALTENCODER) &&
           VerifyField<rj::REVCANAnalog>(verifier, VT_ANALOG) &&
           VerifyField<rj::REVPIDController>(verifier, VT_PID0) &&
           VerifyField<rj::REVPIDController>(verifier, VT_PID1) &&
           VerifyField<rj::REVPIDController>(verifier, VT_PID2) &&
           VerifyField<rj::REVPIDController>(verifier, VT_PID3) &&
           VerifyField<rj::REVCANDigitalInput>(verifier, VT_FWDLIMITSWITCH) &&
           VerifyField<rj::REVCANDigitalInput>(verifier, VT_REVLIMITSWITCH) &&
           VerifyField<uint8_t>(verifier, VT_IDLEMODE) &&
           VerifyField<double>(verifier, VT_VOLTAGECOMPENSATIONNOMINALVOLTAGE) &&
           VerifyField<double>(verifier, VT_OPENLOOPRAMPRATE) &&
           VerifyField<double>(verifier, VT_CLOSEDLOOPRAMPRATE) &&
           VerifyField<double>(verifier, VT_BUSVOLTAGE) &&
           VerifyField<double>(verifier, VT_APPLIEDOUTPUT) &&
           VerifyField<double>(verifier, VT_OUTPUTCURRENT) &&
           VerifyField<double>(verifier, VT_TEMPERATURE) &&
           VerifyField<uint8_t>(verifier, VT_SOFTLIMITFORWARDENABLED) &&
           VerifyField<uint8_t>(verifier, VT_SOFTLIMITREVERSEENABLED) &&
           VerifyField<double>(verifier, VT_SOFTLIMITFORWARDVALUE) &&
           VerifyField<double>(verifier, VT_SOFTLIMITREVERSEVALUE) &&
           VerifyField<uint8_t>(verifier, VT_LASTERROR) &&
           verifier.EndTable();
  }
};

struct REVMotorStatusFrameBuilder {
  typedef REVMotorStatusFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_firmwareVersion(uint32_t firmwareVersion) {
    fbb_.AddElement<uint32_t>(REVMotorStatusFrame::VT_FIRMWAREVERSION, firmwareVersion, 0);
  }
  void add_firmwareString(flatbuffers::Offset<flatbuffers::String> firmwareString) {
    fbb_.AddOffset(REVMotorStatusFrame::VT_FIRMWARESTRING, firmwareString);
  }
  void add_serialNumber(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialNumber) {
    fbb_.AddOffset(REVMotorStatusFrame::VT_SERIALNUMBER, serialNumber);
  }
  void add_deviceID(int32_t deviceID) {
    fbb_.AddElement<int32_t>(REVMotorStatusFrame::VT_DEVICEID, deviceID, 0);
  }
  void add_encoder(const rj::REVCANEncoder *encoder) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_ENCODER, encoder);
  }
  void add_altEncoder(const rj::REVCANEncoder *altEncoder) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_ALTENCODER, altEncoder);
  }
  void add_analog(const rj::REVCANAnalog *analog) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_ANALOG, analog);
  }
  void add_pid0(const rj::REVPIDController *pid0) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_PID0, pid0);
  }
  void add_pid1(const rj::REVPIDController *pid1) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_PID1, pid1);
  }
  void add_pid2(const rj::REVPIDController *pid2) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_PID2, pid2);
  }
  void add_pid3(const rj::REVPIDController *pid3) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_PID3, pid3);
  }
  void add_fwdLimitSwitch(const rj::REVCANDigitalInput *fwdLimitSwitch) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_FWDLIMITSWITCH, fwdLimitSwitch);
  }
  void add_revLimitSwitch(const rj::REVCANDigitalInput *revLimitSwitch) {
    fbb_.AddStruct(REVMotorStatusFrame::VT_REVLIMITSWITCH, revLimitSwitch);
  }
  void add_idleMode(bool idleMode) {
    fbb_.AddElement<uint8_t>(REVMotorStatusFrame::VT_IDLEMODE, static_cast<uint8_t>(idleMode), 0);
  }
  void add_voltageCompensationNominalVoltage(double voltageCompensationNominalVoltage) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_VOLTAGECOMPENSATIONNOMINALVOLTAGE, voltageCompensationNominalVoltage, 0.0);
  }
  void add_openLoopRampRate(double openLoopRampRate) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_OPENLOOPRAMPRATE, openLoopRampRate, 0.0);
  }
  void add_closedLoopRampRate(double closedLoopRampRate) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_CLOSEDLOOPRAMPRATE, closedLoopRampRate, 0.0);
  }
  void add_busVoltage(double busVoltage) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_BUSVOLTAGE, busVoltage, 0.0);
  }
  void add_appliedOutput(double appliedOutput) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_APPLIEDOUTPUT, appliedOutput, 0.0);
  }
  void add_outputCurrent(double outputCurrent) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_OUTPUTCURRENT, outputCurrent, 0.0);
  }
  void add_temperature(double temperature) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_TEMPERATURE, temperature, 0.0);
  }
  void add_softLimitForwardEnabled(bool softLimitForwardEnabled) {
    fbb_.AddElement<uint8_t>(REVMotorStatusFrame::VT_SOFTLIMITFORWARDENABLED, static_cast<uint8_t>(softLimitForwardEnabled), 0);
  }
  void add_softLimitReverseEnabled(bool softLimitReverseEnabled) {
    fbb_.AddElement<uint8_t>(REVMotorStatusFrame::VT_SOFTLIMITREVERSEENABLED, static_cast<uint8_t>(softLimitReverseEnabled), 0);
  }
  void add_softLimitForwardValue(double softLimitForwardValue) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_SOFTLIMITFORWARDVALUE, softLimitForwardValue, 0.0);
  }
  void add_softLimitReverseValue(double softLimitReverseValue) {
    fbb_.AddElement<double>(REVMotorStatusFrame::VT_SOFTLIMITREVERSEVALUE, softLimitReverseValue, 0.0);
  }
  void add_lastError(uint8_t lastError) {
    fbb_.AddElement<uint8_t>(REVMotorStatusFrame::VT_LASTERROR, lastError, 0);
  }
  explicit REVMotorStatusFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<REVMotorStatusFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REVMotorStatusFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<REVMotorStatusFrame> CreateREVMotorStatusFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t firmwareVersion = 0,
    flatbuffers::Offset<flatbuffers::String> firmwareString = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> serialNumber = 0,
    int32_t deviceID = 0,
    const rj::REVCANEncoder *encoder = 0,
    const rj::REVCANEncoder *altEncoder = 0,
    const rj::REVCANAnalog *analog = 0,
    const rj::REVPIDController *pid0 = 0,
    const rj::REVPIDController *pid1 = 0,
    const rj::REVPIDController *pid2 = 0,
    const rj::REVPIDController *pid3 = 0,
    const rj::REVCANDigitalInput *fwdLimitSwitch = 0,
    const rj::REVCANDigitalInput *revLimitSwitch = 0,
    bool idleMode = false,
    double voltageCompensationNominalVoltage = 0.0,
    double openLoopRampRate = 0.0,
    double closedLoopRampRate = 0.0,
    double busVoltage = 0.0,
    double appliedOutput = 0.0,
    double outputCurrent = 0.0,
    double temperature = 0.0,
    bool softLimitForwardEnabled = false,
    bool softLimitReverseEnabled = false,
    double softLimitForwardValue = 0.0,
    double softLimitReverseValue = 0.0,
    uint8_t lastError = 0) {
  REVMotorStatusFrameBuilder builder_(_fbb);
  builder_.add_softLimitReverseValue(softLimitReverseValue);
  builder_.add_softLimitForwardValue(softLimitForwardValue);
  builder_.add_temperature(temperature);
  builder_.add_outputCurrent(outputCurrent);
  builder_.add_appliedOutput(appliedOutput);
  builder_.add_busVoltage(busVoltage);
  builder_.add_closedLoopRampRate(closedLoopRampRate);
  builder_.add_openLoopRampRate(openLoopRampRate);
  builder_.add_voltageCompensationNominalVoltage(voltageCompensationNominalVoltage);
  builder_.add_revLimitSwitch(revLimitSwitch);
  builder_.add_fwdLimitSwitch(fwdLimitSwitch);
  builder_.add_pid3(pid3);
  builder_.add_pid2(pid2);
  builder_.add_pid1(pid1);
  builder_.add_pid0(pid0);
  builder_.add_analog(analog);
  builder_.add_altEncoder(altEncoder);
  builder_.add_encoder(encoder);
  builder_.add_deviceID(deviceID);
  builder_.add_serialNumber(serialNumber);
  builder_.add_firmwareString(firmwareString);
  builder_.add_firmwareVersion(firmwareVersion);
  builder_.add_lastError(lastError);
  builder_.add_softLimitReverseEnabled(softLimitReverseEnabled);
  builder_.add_softLimitForwardEnabled(softLimitForwardEnabled);
  builder_.add_idleMode(idleMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<REVMotorStatusFrame> CreateREVMotorStatusFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t firmwareVersion = 0,
    const char *firmwareString = nullptr,
    const std::vector<uint8_t> *serialNumber = nullptr,
    int32_t deviceID = 0,
    const rj::REVCANEncoder *encoder = 0,
    const rj::REVCANEncoder *altEncoder = 0,
    const rj::REVCANAnalog *analog = 0,
    const rj::REVPIDController *pid0 = 0,
    const rj::REVPIDController *pid1 = 0,
    const rj::REVPIDController *pid2 = 0,
    const rj::REVPIDController *pid3 = 0,
    const rj::REVCANDigitalInput *fwdLimitSwitch = 0,
    const rj::REVCANDigitalInput *revLimitSwitch = 0,
    bool idleMode = false,
    double voltageCompensationNominalVoltage = 0.0,
    double openLoopRampRate = 0.0,
    double closedLoopRampRate = 0.0,
    double busVoltage = 0.0,
    double appliedOutput = 0.0,
    double outputCurrent = 0.0,
    double temperature = 0.0,
    bool softLimitForwardEnabled = false,
    bool softLimitReverseEnabled = false,
    double softLimitForwardValue = 0.0,
    double softLimitReverseValue = 0.0,
    uint8_t lastError = 0) {
  auto firmwareString__ = firmwareString ? _fbb.CreateString(firmwareString) : 0;
  auto serialNumber__ = serialNumber ? _fbb.CreateVector<uint8_t>(*serialNumber) : 0;
  return rj::CreateREVMotorStatusFrame(
      _fbb,
      firmwareVersion,
      firmwareString__,
      serialNumber__,
      deviceID,
      encoder,
      altEncoder,
      analog,
      pid0,
      pid1,
      pid2,
      pid3,
      fwdLimitSwitch,
      revLimitSwitch,
      idleMode,
      voltageCompensationNominalVoltage,
      openLoopRampRate,
      closedLoopRampRate,
      busVoltage,
      appliedOutput,
      outputCurrent,
      temperature,
      softLimitForwardEnabled,
      softLimitReverseEnabled,
      softLimitForwardValue,
      softLimitReverseValue,
      lastError);
}

struct REVColorSensorStatusFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REVColorSensorStatusFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR = 4,
    VT_PROXIMITY = 6,
    VT_RESET = 8
  };
  const rj::RawColor *color() const {
    return GetStruct<const rj::RawColor *>(VT_COLOR);
  }
  uint32_t proximity() const {
    return GetField<uint32_t>(VT_PROXIMITY, 0);
  }
  bool reset() const {
    return GetField<uint8_t>(VT_RESET, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<rj::RawColor>(verifier, VT_COLOR) &&
           VerifyField<uint32_t>(verifier, VT_PROXIMITY) &&
           VerifyField<uint8_t>(verifier, VT_RESET) &&
           verifier.EndTable();
  }
};

struct REVColorSensorStatusFrameBuilder {
  typedef REVColorSensorStatusFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(const rj::RawColor *color) {
    fbb_.AddStruct(REVColorSensorStatusFrame::VT_COLOR, color);
  }
  void add_proximity(uint32_t proximity) {
    fbb_.AddElement<uint32_t>(REVColorSensorStatusFrame::VT_PROXIMITY, proximity, 0);
  }
  void add_reset(bool reset) {
    fbb_.AddElement<uint8_t>(REVColorSensorStatusFrame::VT_RESET, static_cast<uint8_t>(reset), 0);
  }
  explicit REVColorSensorStatusFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<REVColorSensorStatusFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REVColorSensorStatusFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<REVColorSensorStatusFrame> CreateREVColorSensorStatusFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    const rj::RawColor *color = 0,
    uint32_t proximity = 0,
    bool reset = false) {
  REVColorSensorStatusFrameBuilder builder_(_fbb);
  builder_.add_proximity(proximity);
  builder_.add_color(color);
  builder_.add_reset(reset);
  return builder_.Finish();
}

struct NavXStatusFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NavXStatusFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PITCH = 4,
    VT_ROLL = 6,
    VT_YAW = 8,
    VT_COMPASSHEADING = 10,
    VT_ISCALIBRATING = 12,
    VT_ISCONNECTED = 14,
    VT_BYTECOUNT = 16,
    VT_UPDATECOUNT = 18,
    VT_LASTSENSORTIMESTAMP = 20,
    VT_WORLDLINEARACCELX = 22,
    VT_WORLDLINEARACCELY = 24,
    VT_WORLDLINEARACCELZ = 26,
    VT_ISMOVING = 28,
    VT_ISROTATING = 30,
    VT_BAROMETRICPRESSURE = 32,
    VT_ALTITUDE = 34,
    VT_ISALTITUDEVALID = 36,
    VT_FUSEDHEADING = 38,
    VT_ISMAGNETICDISTURBANCE = 40,
    VT_ISMANETOMETERCALIBRATED = 42,
    VT_QUATERNIONW = 44,
    VT_QUATERNIONX = 46,
    VT_QUATERNIONY = 48,
    VT_QUATERNIONZ = 50,
    VT_VELOCITYX = 52,
    VT_VELOCITYY = 54,
    VT_VELOCITYZ = 56,
    VT_DISPLACEMENTX = 58,
    VT_DISPLACEMENTY = 60,
    VT_DISPLACEMENTZ = 62,
    VT_ANGLE = 64,
    VT_RATE = 66,
    VT_ANGLEADJUSTMENT = 68,
    VT_RAWGYROX = 70,
    VT_RAWGYROY = 72,
    VT_RAWGYROZ = 74,
    VT_RAWACCELX = 76,
    VT_RAWACCELY = 78,
    VT_RAWACCELZ = 80,
    VT_RAWMAGX = 82,
    VT_RAWMAXY = 84,
    VT_RAWMAGZ = 86,
    VT_PRESSURE = 88,
    VT_TEMPC = 90,
    VT_BOARDYAWAXIS = 92,
    VT_FIRMWAREVERSION = 94,
    VT_ACTUALUPDATERATE = 96,
    VT_REQUESTEDUPDATERATE = 98,
    VT_ISBOARDLEVELYAWRESETENABLED = 100,
    VT_GYROFULLSCALERANGEDPS = 102,
    VT_ACCELFULLSCALERANGEG = 104
  };
  float pitch() const {
    return GetField<float>(VT_PITCH, 0.0f);
  }
  float roll() const {
    return GetField<float>(VT_ROLL, 0.0f);
  }
  float yaw() const {
    return GetField<float>(VT_YAW, 0.0f);
  }
  float compassHeading() const {
    return GetField<float>(VT_COMPASSHEADING, 0.0f);
  }
  bool isCalibrating() const {
    return GetField<uint8_t>(VT_ISCALIBRATING, 0) != 0;
  }
  bool isConnected() const {
    return GetField<uint8_t>(VT_ISCONNECTED, 0) != 0;
  }
  double byteCount() const {
    return GetField<double>(VT_BYTECOUNT, 0.0);
  }
  double updateCount() const {
    return GetField<double>(VT_UPDATECOUNT, 0.0);
  }
  uint64_t lastSensorTimestamp() const {
    return GetField<uint64_t>(VT_LASTSENSORTIMESTAMP, 0);
  }
  float worldLinearAccelX() const {
    return GetField<float>(VT_WORLDLINEARACCELX, 0.0f);
  }
  float worldLinearAccelY() const {
    return GetField<float>(VT_WORLDLINEARACCELY, 0.0f);
  }
  float worldLinearAccelZ() const {
    return GetField<float>(VT_WORLDLINEARACCELZ, 0.0f);
  }
  bool isMoving() const {
    return GetField<uint8_t>(VT_ISMOVING, 0) != 0;
  }
  bool isRotating() const {
    return GetField<uint8_t>(VT_ISROTATING, 0) != 0;
  }
  float barometricPressure() const {
    return GetField<float>(VT_BAROMETRICPRESSURE, 0.0f);
  }
  float altitude() const {
    return GetField<float>(VT_ALTITUDE, 0.0f);
  }
  bool isAltitudeValid() const {
    return GetField<uint8_t>(VT_ISALTITUDEVALID, 0) != 0;
  }
  float fusedHeading() const {
    return GetField<float>(VT_FUSEDHEADING, 0.0f);
  }
  bool isMagneticDisturbance() const {
    return GetField<uint8_t>(VT_ISMAGNETICDISTURBANCE, 0) != 0;
  }
  bool isManetometerCalibrated() const {
    return GetField<uint8_t>(VT_ISMANETOMETERCALIBRATED, 0) != 0;
  }
  float quaternionW() const {
    return GetField<float>(VT_QUATERNIONW, 0.0f);
  }
  float quaternionX() const {
    return GetField<float>(VT_QUATERNIONX, 0.0f);
  }
  float quaternionY() const {
    return GetField<float>(VT_QUATERNIONY, 0.0f);
  }
  float quaternionZ() const {
    return GetField<float>(VT_QUATERNIONZ, 0.0f);
  }
  float velocityX() const {
    return GetField<float>(VT_VELOCITYX, 0.0f);
  }
  float velocityY() const {
    return GetField<float>(VT_VELOCITYY, 0.0f);
  }
  float velocityZ() const {
    return GetField<float>(VT_VELOCITYZ, 0.0f);
  }
  float displacementX() const {
    return GetField<float>(VT_DISPLACEMENTX, 0.0f);
  }
  float displacementY() const {
    return GetField<float>(VT_DISPLACEMENTY, 0.0f);
  }
  float displacementZ() const {
    return GetField<float>(VT_DISPLACEMENTZ, 0.0f);
  }
  double angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  double angleAdjustment() const {
    return GetField<double>(VT_ANGLEADJUSTMENT, 0.0);
  }
  float rawGyroX() const {
    return GetField<float>(VT_RAWGYROX, 0.0f);
  }
  float rawGyroY() const {
    return GetField<float>(VT_RAWGYROY, 0.0f);
  }
  float rawGyroZ() const {
    return GetField<float>(VT_RAWGYROZ, 0.0f);
  }
  float rawAccelX() const {
    return GetField<float>(VT_RAWACCELX, 0.0f);
  }
  float rawAccelY() const {
    return GetField<float>(VT_RAWACCELY, 0.0f);
  }
  float rawAccelZ() const {
    return GetField<float>(VT_RAWACCELZ, 0.0f);
  }
  float rawMagX() const {
    return GetField<float>(VT_RAWMAGX, 0.0f);
  }
  float rawMaxY() const {
    return GetField<float>(VT_RAWMAXY, 0.0f);
  }
  float rawMagZ() const {
    return GetField<float>(VT_RAWMAGZ, 0.0f);
  }
  float pressure() const {
    return GetField<float>(VT_PRESSURE, 0.0f);
  }
  float tempC() const {
    return GetField<float>(VT_TEMPC, 0.0f);
  }
  const rj::BoardYawAxis *boardYawAxis() const {
    return GetStruct<const rj::BoardYawAxis *>(VT_BOARDYAWAXIS);
  }
  const flatbuffers::String *firmwareVersion() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRMWAREVERSION);
  }
  int32_t actualUpdateRate() const {
    return GetField<int32_t>(VT_ACTUALUPDATERATE, 0);
  }
  int32_t requestedUpdateRate() const {
    return GetField<int32_t>(VT_REQUESTEDUPDATERATE, 0);
  }
  bool isBoardLevelYawResetEnabled() const {
    return GetField<uint8_t>(VT_ISBOARDLEVELYAWRESETENABLED, 0) != 0;
  }
  int16_t gyroFullScaleRangeDPS() const {
    return GetField<int16_t>(VT_GYROFULLSCALERANGEDPS, 0);
  }
  int16_t accelFullScaleRangeG() const {
    return GetField<int16_t>(VT_ACCELFULLSCALERANGEG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_PITCH) &&
           VerifyField<float>(verifier, VT_ROLL) &&
           VerifyField<float>(verifier, VT_YAW) &&
           VerifyField<float>(verifier, VT_COMPASSHEADING) &&
           VerifyField<uint8_t>(verifier, VT_ISCALIBRATING) &&
           VerifyField<uint8_t>(verifier, VT_ISCONNECTED) &&
           VerifyField<double>(verifier, VT_BYTECOUNT) &&
           VerifyField<double>(verifier, VT_UPDATECOUNT) &&
           VerifyField<uint64_t>(verifier, VT_LASTSENSORTIMESTAMP) &&
           VerifyField<float>(verifier, VT_WORLDLINEARACCELX) &&
           VerifyField<float>(verifier, VT_WORLDLINEARACCELY) &&
           VerifyField<float>(verifier, VT_WORLDLINEARACCELZ) &&
           VerifyField<uint8_t>(verifier, VT_ISMOVING) &&
           VerifyField<uint8_t>(verifier, VT_ISROTATING) &&
           VerifyField<float>(verifier, VT_BAROMETRICPRESSURE) &&
           VerifyField<float>(verifier, VT_ALTITUDE) &&
           VerifyField<uint8_t>(verifier, VT_ISALTITUDEVALID) &&
           VerifyField<float>(verifier, VT_FUSEDHEADING) &&
           VerifyField<uint8_t>(verifier, VT_ISMAGNETICDISTURBANCE) &&
           VerifyField<uint8_t>(verifier, VT_ISMANETOMETERCALIBRATED) &&
           VerifyField<float>(verifier, VT_QUATERNIONW) &&
           VerifyField<float>(verifier, VT_QUATERNIONX) &&
           VerifyField<float>(verifier, VT_QUATERNIONY) &&
           VerifyField<float>(verifier, VT_QUATERNIONZ) &&
           VerifyField<float>(verifier, VT_VELOCITYX) &&
           VerifyField<float>(verifier, VT_VELOCITYY) &&
           VerifyField<float>(verifier, VT_VELOCITYZ) &&
           VerifyField<float>(verifier, VT_DISPLACEMENTX) &&
           VerifyField<float>(verifier, VT_DISPLACEMENTY) &&
           VerifyField<float>(verifier, VT_DISPLACEMENTZ) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           VerifyField<double>(verifier, VT_RATE) &&
           VerifyField<double>(verifier, VT_ANGLEADJUSTMENT) &&
           VerifyField<float>(verifier, VT_RAWGYROX) &&
           VerifyField<float>(verifier, VT_RAWGYROY) &&
           VerifyField<float>(verifier, VT_RAWGYROZ) &&
           VerifyField<float>(verifier, VT_RAWACCELX) &&
           VerifyField<float>(verifier, VT_RAWACCELY) &&
           VerifyField<float>(verifier, VT_RAWACCELZ) &&
           VerifyField<float>(verifier, VT_RAWMAGX) &&
           VerifyField<float>(verifier, VT_RAWMAXY) &&
           VerifyField<float>(verifier, VT_RAWMAGZ) &&
           VerifyField<float>(verifier, VT_PRESSURE) &&
           VerifyField<float>(verifier, VT_TEMPC) &&
           VerifyField<rj::BoardYawAxis>(verifier, VT_BOARDYAWAXIS) &&
           VerifyOffset(verifier, VT_FIRMWAREVERSION) &&
           verifier.VerifyString(firmwareVersion()) &&
           VerifyField<int32_t>(verifier, VT_ACTUALUPDATERATE) &&
           VerifyField<int32_t>(verifier, VT_REQUESTEDUPDATERATE) &&
           VerifyField<uint8_t>(verifier, VT_ISBOARDLEVELYAWRESETENABLED) &&
           VerifyField<int16_t>(verifier, VT_GYROFULLSCALERANGEDPS) &&
           VerifyField<int16_t>(verifier, VT_ACCELFULLSCALERANGEG) &&
           verifier.EndTable();
  }
};

struct NavXStatusFrameBuilder {
  typedef NavXStatusFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pitch(float pitch) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_PITCH, pitch, 0.0f);
  }
  void add_roll(float roll) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_ROLL, roll, 0.0f);
  }
  void add_yaw(float yaw) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_YAW, yaw, 0.0f);
  }
  void add_compassHeading(float compassHeading) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_COMPASSHEADING, compassHeading, 0.0f);
  }
  void add_isCalibrating(bool isCalibrating) {
    fbb_.AddElement<uint8_t>(NavXStatusFrame::VT_ISCALIBRATING, static_cast<uint8_t>(isCalibrating), 0);
  }
  void add_isConnected(bool isConnected) {
    fbb_.AddElement<uint8_t>(NavXStatusFrame::VT_ISCONNECTED, static_cast<uint8_t>(isConnected), 0);
  }
  void add_byteCount(double byteCount) {
    fbb_.AddElement<double>(NavXStatusFrame::VT_BYTECOUNT, byteCount, 0.0);
  }
  void add_updateCount(double updateCount) {
    fbb_.AddElement<double>(NavXStatusFrame::VT_UPDATECOUNT, updateCount, 0.0);
  }
  void add_lastSensorTimestamp(uint64_t lastSensorTimestamp) {
    fbb_.AddElement<uint64_t>(NavXStatusFrame::VT_LASTSENSORTIMESTAMP, lastSensorTimestamp, 0);
  }
  void add_worldLinearAccelX(float worldLinearAccelX) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_WORLDLINEARACCELX, worldLinearAccelX, 0.0f);
  }
  void add_worldLinearAccelY(float worldLinearAccelY) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_WORLDLINEARACCELY, worldLinearAccelY, 0.0f);
  }
  void add_worldLinearAccelZ(float worldLinearAccelZ) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_WORLDLINEARACCELZ, worldLinearAccelZ, 0.0f);
  }
  void add_isMoving(bool isMoving) {
    fbb_.AddElement<uint8_t>(NavXStatusFrame::VT_ISMOVING, static_cast<uint8_t>(isMoving), 0);
  }
  void add_isRotating(bool isRotating) {
    fbb_.AddElement<uint8_t>(NavXStatusFrame::VT_ISROTATING, static_cast<uint8_t>(isRotating), 0);
  }
  void add_barometricPressure(float barometricPressure) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_BAROMETRICPRESSURE, barometricPressure, 0.0f);
  }
  void add_altitude(float altitude) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_ALTITUDE, altitude, 0.0f);
  }
  void add_isAltitudeValid(bool isAltitudeValid) {
    fbb_.AddElement<uint8_t>(NavXStatusFrame::VT_ISALTITUDEVALID, static_cast<uint8_t>(isAltitudeValid), 0);
  }
  void add_fusedHeading(float fusedHeading) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_FUSEDHEADING, fusedHeading, 0.0f);
  }
  void add_isMagneticDisturbance(bool isMagneticDisturbance) {
    fbb_.AddElement<uint8_t>(NavXStatusFrame::VT_ISMAGNETICDISTURBANCE, static_cast<uint8_t>(isMagneticDisturbance), 0);
  }
  void add_isManetometerCalibrated(bool isManetometerCalibrated) {
    fbb_.AddElement<uint8_t>(NavXStatusFrame::VT_ISMANETOMETERCALIBRATED, static_cast<uint8_t>(isManetometerCalibrated), 0);
  }
  void add_quaternionW(float quaternionW) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_QUATERNIONW, quaternionW, 0.0f);
  }
  void add_quaternionX(float quaternionX) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_QUATERNIONX, quaternionX, 0.0f);
  }
  void add_quaternionY(float quaternionY) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_QUATERNIONY, quaternionY, 0.0f);
  }
  void add_quaternionZ(float quaternionZ) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_QUATERNIONZ, quaternionZ, 0.0f);
  }
  void add_velocityX(float velocityX) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_VELOCITYX, velocityX, 0.0f);
  }
  void add_velocityY(float velocityY) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_VELOCITYY, velocityY, 0.0f);
  }
  void add_velocityZ(float velocityZ) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_VELOCITYZ, velocityZ, 0.0f);
  }
  void add_displacementX(float displacementX) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_DISPLACEMENTX, displacementX, 0.0f);
  }
  void add_displacementY(float displacementY) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_DISPLACEMENTY, displacementY, 0.0f);
  }
  void add_displacementZ(float displacementZ) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_DISPLACEMENTZ, displacementZ, 0.0f);
  }
  void add_angle(double angle) {
    fbb_.AddElement<double>(NavXStatusFrame::VT_ANGLE, angle, 0.0);
  }
  void add_rate(double rate) {
    fbb_.AddElement<double>(NavXStatusFrame::VT_RATE, rate, 0.0);
  }
  void add_angleAdjustment(double angleAdjustment) {
    fbb_.AddElement<double>(NavXStatusFrame::VT_ANGLEADJUSTMENT, angleAdjustment, 0.0);
  }
  void add_rawGyroX(float rawGyroX) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWGYROX, rawGyroX, 0.0f);
  }
  void add_rawGyroY(float rawGyroY) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWGYROY, rawGyroY, 0.0f);
  }
  void add_rawGyroZ(float rawGyroZ) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWGYROZ, rawGyroZ, 0.0f);
  }
  void add_rawAccelX(float rawAccelX) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWACCELX, rawAccelX, 0.0f);
  }
  void add_rawAccelY(float rawAccelY) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWACCELY, rawAccelY, 0.0f);
  }
  void add_rawAccelZ(float rawAccelZ) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWACCELZ, rawAccelZ, 0.0f);
  }
  void add_rawMagX(float rawMagX) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWMAGX, rawMagX, 0.0f);
  }
  void add_rawMaxY(float rawMaxY) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWMAXY, rawMaxY, 0.0f);
  }
  void add_rawMagZ(float rawMagZ) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_RAWMAGZ, rawMagZ, 0.0f);
  }
  void add_pressure(float pressure) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_PRESSURE, pressure, 0.0f);
  }
  void add_tempC(float tempC) {
    fbb_.AddElement<float>(NavXStatusFrame::VT_TEMPC, tempC, 0.0f);
  }
  void add_boardYawAxis(const rj::BoardYawAxis *boardYawAxis) {
    fbb_.AddStruct(NavXStatusFrame::VT_BOARDYAWAXIS, boardYawAxis);
  }
  void add_firmwareVersion(flatbuffers::Offset<flatbuffers::String> firmwareVersion) {
    fbb_.AddOffset(NavXStatusFrame::VT_FIRMWAREVERSION, firmwareVersion);
  }
  void add_actualUpdateRate(int32_t actualUpdateRate) {
    fbb_.AddElement<int32_t>(NavXStatusFrame::VT_ACTUALUPDATERATE, actualUpdateRate, 0);
  }
  void add_requestedUpdateRate(int32_t requestedUpdateRate) {
    fbb_.AddElement<int32_t>(NavXStatusFrame::VT_REQUESTEDUPDATERATE, requestedUpdateRate, 0);
  }
  void add_isBoardLevelYawResetEnabled(bool isBoardLevelYawResetEnabled) {
    fbb_.AddElement<uint8_t>(NavXStatusFrame::VT_ISBOARDLEVELYAWRESETENABLED, static_cast<uint8_t>(isBoardLevelYawResetEnabled), 0);
  }
  void add_gyroFullScaleRangeDPS(int16_t gyroFullScaleRangeDPS) {
    fbb_.AddElement<int16_t>(NavXStatusFrame::VT_GYROFULLSCALERANGEDPS, gyroFullScaleRangeDPS, 0);
  }
  void add_accelFullScaleRangeG(int16_t accelFullScaleRangeG) {
    fbb_.AddElement<int16_t>(NavXStatusFrame::VT_ACCELFULLSCALERANGEG, accelFullScaleRangeG, 0);
  }
  explicit NavXStatusFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NavXStatusFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NavXStatusFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<NavXStatusFrame> CreateNavXStatusFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    float pitch = 0.0f,
    float roll = 0.0f,
    float yaw = 0.0f,
    float compassHeading = 0.0f,
    bool isCalibrating = false,
    bool isConnected = false,
    double byteCount = 0.0,
    double updateCount = 0.0,
    uint64_t lastSensorTimestamp = 0,
    float worldLinearAccelX = 0.0f,
    float worldLinearAccelY = 0.0f,
    float worldLinearAccelZ = 0.0f,
    bool isMoving = false,
    bool isRotating = false,
    float barometricPressure = 0.0f,
    float altitude = 0.0f,
    bool isAltitudeValid = false,
    float fusedHeading = 0.0f,
    bool isMagneticDisturbance = false,
    bool isManetometerCalibrated = false,
    float quaternionW = 0.0f,
    float quaternionX = 0.0f,
    float quaternionY = 0.0f,
    float quaternionZ = 0.0f,
    float velocityX = 0.0f,
    float velocityY = 0.0f,
    float velocityZ = 0.0f,
    float displacementX = 0.0f,
    float displacementY = 0.0f,
    float displacementZ = 0.0f,
    double angle = 0.0,
    double rate = 0.0,
    double angleAdjustment = 0.0,
    float rawGyroX = 0.0f,
    float rawGyroY = 0.0f,
    float rawGyroZ = 0.0f,
    float rawAccelX = 0.0f,
    float rawAccelY = 0.0f,
    float rawAccelZ = 0.0f,
    float rawMagX = 0.0f,
    float rawMaxY = 0.0f,
    float rawMagZ = 0.0f,
    float pressure = 0.0f,
    float tempC = 0.0f,
    const rj::BoardYawAxis *boardYawAxis = 0,
    flatbuffers::Offset<flatbuffers::String> firmwareVersion = 0,
    int32_t actualUpdateRate = 0,
    int32_t requestedUpdateRate = 0,
    bool isBoardLevelYawResetEnabled = false,
    int16_t gyroFullScaleRangeDPS = 0,
    int16_t accelFullScaleRangeG = 0) {
  NavXStatusFrameBuilder builder_(_fbb);
  builder_.add_angleAdjustment(angleAdjustment);
  builder_.add_rate(rate);
  builder_.add_angle(angle);
  builder_.add_lastSensorTimestamp(lastSensorTimestamp);
  builder_.add_updateCount(updateCount);
  builder_.add_byteCount(byteCount);
  builder_.add_requestedUpdateRate(requestedUpdateRate);
  builder_.add_actualUpdateRate(actualUpdateRate);
  builder_.add_firmwareVersion(firmwareVersion);
  builder_.add_boardYawAxis(boardYawAxis);
  builder_.add_tempC(tempC);
  builder_.add_pressure(pressure);
  builder_.add_rawMagZ(rawMagZ);
  builder_.add_rawMaxY(rawMaxY);
  builder_.add_rawMagX(rawMagX);
  builder_.add_rawAccelZ(rawAccelZ);
  builder_.add_rawAccelY(rawAccelY);
  builder_.add_rawAccelX(rawAccelX);
  builder_.add_rawGyroZ(rawGyroZ);
  builder_.add_rawGyroY(rawGyroY);
  builder_.add_rawGyroX(rawGyroX);
  builder_.add_displacementZ(displacementZ);
  builder_.add_displacementY(displacementY);
  builder_.add_displacementX(displacementX);
  builder_.add_velocityZ(velocityZ);
  builder_.add_velocityY(velocityY);
  builder_.add_velocityX(velocityX);
  builder_.add_quaternionZ(quaternionZ);
  builder_.add_quaternionY(quaternionY);
  builder_.add_quaternionX(quaternionX);
  builder_.add_quaternionW(quaternionW);
  builder_.add_fusedHeading(fusedHeading);
  builder_.add_altitude(altitude);
  builder_.add_barometricPressure(barometricPressure);
  builder_.add_worldLinearAccelZ(worldLinearAccelZ);
  builder_.add_worldLinearAccelY(worldLinearAccelY);
  builder_.add_worldLinearAccelX(worldLinearAccelX);
  builder_.add_compassHeading(compassHeading);
  builder_.add_yaw(yaw);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  builder_.add_accelFullScaleRangeG(accelFullScaleRangeG);
  builder_.add_gyroFullScaleRangeDPS(gyroFullScaleRangeDPS);
  builder_.add_isBoardLevelYawResetEnabled(isBoardLevelYawResetEnabled);
  builder_.add_isManetometerCalibrated(isManetometerCalibrated);
  builder_.add_isMagneticDisturbance(isMagneticDisturbance);
  builder_.add_isAltitudeValid(isAltitudeValid);
  builder_.add_isRotating(isRotating);
  builder_.add_isMoving(isMoving);
  builder_.add_isConnected(isConnected);
  builder_.add_isCalibrating(isCalibrating);
  return builder_.Finish();
}

inline flatbuffers::Offset<NavXStatusFrame> CreateNavXStatusFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float pitch = 0.0f,
    float roll = 0.0f,
    float yaw = 0.0f,
    float compassHeading = 0.0f,
    bool isCalibrating = false,
    bool isConnected = false,
    double byteCount = 0.0,
    double updateCount = 0.0,
    uint64_t lastSensorTimestamp = 0,
    float worldLinearAccelX = 0.0f,
    float worldLinearAccelY = 0.0f,
    float worldLinearAccelZ = 0.0f,
    bool isMoving = false,
    bool isRotating = false,
    float barometricPressure = 0.0f,
    float altitude = 0.0f,
    bool isAltitudeValid = false,
    float fusedHeading = 0.0f,
    bool isMagneticDisturbance = false,
    bool isManetometerCalibrated = false,
    float quaternionW = 0.0f,
    float quaternionX = 0.0f,
    float quaternionY = 0.0f,
    float quaternionZ = 0.0f,
    float velocityX = 0.0f,
    float velocityY = 0.0f,
    float velocityZ = 0.0f,
    float displacementX = 0.0f,
    float displacementY = 0.0f,
    float displacementZ = 0.0f,
    double angle = 0.0,
    double rate = 0.0,
    double angleAdjustment = 0.0,
    float rawGyroX = 0.0f,
    float rawGyroY = 0.0f,
    float rawGyroZ = 0.0f,
    float rawAccelX = 0.0f,
    float rawAccelY = 0.0f,
    float rawAccelZ = 0.0f,
    float rawMagX = 0.0f,
    float rawMaxY = 0.0f,
    float rawMagZ = 0.0f,
    float pressure = 0.0f,
    float tempC = 0.0f,
    const rj::BoardYawAxis *boardYawAxis = 0,
    const char *firmwareVersion = nullptr,
    int32_t actualUpdateRate = 0,
    int32_t requestedUpdateRate = 0,
    bool isBoardLevelYawResetEnabled = false,
    int16_t gyroFullScaleRangeDPS = 0,
    int16_t accelFullScaleRangeG = 0) {
  auto firmwareVersion__ = firmwareVersion ? _fbb.CreateString(firmwareVersion) : 0;
  return rj::CreateNavXStatusFrame(
      _fbb,
      pitch,
      roll,
      yaw,
      compassHeading,
      isCalibrating,
      isConnected,
      byteCount,
      updateCount,
      lastSensorTimestamp,
      worldLinearAccelX,
      worldLinearAccelY,
      worldLinearAccelZ,
      isMoving,
      isRotating,
      barometricPressure,
      altitude,
      isAltitudeValid,
      fusedHeading,
      isMagneticDisturbance,
      isManetometerCalibrated,
      quaternionW,
      quaternionX,
      quaternionY,
      quaternionZ,
      velocityX,
      velocityY,
      velocityZ,
      displacementX,
      displacementY,
      displacementZ,
      angle,
      rate,
      angleAdjustment,
      rawGyroX,
      rawGyroY,
      rawGyroZ,
      rawAccelX,
      rawAccelY,
      rawAccelZ,
      rawMagX,
      rawMaxY,
      rawMagZ,
      pressure,
      tempC,
      boardYawAxis,
      firmwareVersion__,
      actualUpdateRate,
      requestedUpdateRate,
      isBoardLevelYawResetEnabled,
      gyroFullScaleRangeDPS,
      accelFullScaleRangeG);
}

struct ADIS16470StatusFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ADIS16470StatusFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGLE = 4,
    VT_RATE = 6,
    VT_GYROINSTANTX = 8,
    VT_GYROINSTANTY = 10,
    VT_GYROINSTANTZ = 12,
    VT_ACCELINSTANTX = 14,
    VT_ACCELINSTANTY = 16,
    VT_ACCELINSTANTZ = 18,
    VT_XCOMPLIMENTARYANGLE = 20,
    VT_YCOMPLIMENTARYANGLE = 22,
    VT_XFILTEREDACCELANGLE = 24,
    VT_YFILTEREDACCELANGLE = 26,
    VT_YAWAXIS = 28
  };
  double angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  double gyroInstantX() const {
    return GetField<double>(VT_GYROINSTANTX, 0.0);
  }
  double gyroInstantY() const {
    return GetField<double>(VT_GYROINSTANTY, 0.0);
  }
  double gyroInstantZ() const {
    return GetField<double>(VT_GYROINSTANTZ, 0.0);
  }
  double accelInstantX() const {
    return GetField<double>(VT_ACCELINSTANTX, 0.0);
  }
  double accelInstantY() const {
    return GetField<double>(VT_ACCELINSTANTY, 0.0);
  }
  double accelInstantZ() const {
    return GetField<double>(VT_ACCELINSTANTZ, 0.0);
  }
  double xComplimentaryAngle() const {
    return GetField<double>(VT_XCOMPLIMENTARYANGLE, 0.0);
  }
  double yComplimentaryAngle() const {
    return GetField<double>(VT_YCOMPLIMENTARYANGLE, 0.0);
  }
  double xFilteredAccelAngle() const {
    return GetField<double>(VT_XFILTEREDACCELANGLE, 0.0);
  }
  double yFilteredAccelAngle() const {
    return GetField<double>(VT_YFILTEREDACCELANGLE, 0.0);
  }
  uint8_t yawAxis() const {
    return GetField<uint8_t>(VT_YAWAXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           VerifyField<double>(verifier, VT_RATE) &&
           VerifyField<double>(verifier, VT_GYROINSTANTX) &&
           VerifyField<double>(verifier, VT_GYROINSTANTY) &&
           VerifyField<double>(verifier, VT_GYROINSTANTZ) &&
           VerifyField<double>(verifier, VT_ACCELINSTANTX) &&
           VerifyField<double>(verifier, VT_ACCELINSTANTY) &&
           VerifyField<double>(verifier, VT_ACCELINSTANTZ) &&
           VerifyField<double>(verifier, VT_XCOMPLIMENTARYANGLE) &&
           VerifyField<double>(verifier, VT_YCOMPLIMENTARYANGLE) &&
           VerifyField<double>(verifier, VT_XFILTEREDACCELANGLE) &&
           VerifyField<double>(verifier, VT_YFILTEREDACCELANGLE) &&
           VerifyField<uint8_t>(verifier, VT_YAWAXIS) &&
           verifier.EndTable();
  }
};

struct ADIS16470StatusFrameBuilder {
  typedef ADIS16470StatusFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_angle(double angle) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_ANGLE, angle, 0.0);
  }
  void add_rate(double rate) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_RATE, rate, 0.0);
  }
  void add_gyroInstantX(double gyroInstantX) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_GYROINSTANTX, gyroInstantX, 0.0);
  }
  void add_gyroInstantY(double gyroInstantY) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_GYROINSTANTY, gyroInstantY, 0.0);
  }
  void add_gyroInstantZ(double gyroInstantZ) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_GYROINSTANTZ, gyroInstantZ, 0.0);
  }
  void add_accelInstantX(double accelInstantX) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_ACCELINSTANTX, accelInstantX, 0.0);
  }
  void add_accelInstantY(double accelInstantY) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_ACCELINSTANTY, accelInstantY, 0.0);
  }
  void add_accelInstantZ(double accelInstantZ) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_ACCELINSTANTZ, accelInstantZ, 0.0);
  }
  void add_xComplimentaryAngle(double xComplimentaryAngle) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_XCOMPLIMENTARYANGLE, xComplimentaryAngle, 0.0);
  }
  void add_yComplimentaryAngle(double yComplimentaryAngle) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_YCOMPLIMENTARYANGLE, yComplimentaryAngle, 0.0);
  }
  void add_xFilteredAccelAngle(double xFilteredAccelAngle) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_XFILTEREDACCELANGLE, xFilteredAccelAngle, 0.0);
  }
  void add_yFilteredAccelAngle(double yFilteredAccelAngle) {
    fbb_.AddElement<double>(ADIS16470StatusFrame::VT_YFILTEREDACCELANGLE, yFilteredAccelAngle, 0.0);
  }
  void add_yawAxis(uint8_t yawAxis) {
    fbb_.AddElement<uint8_t>(ADIS16470StatusFrame::VT_YAWAXIS, yawAxis, 0);
  }
  explicit ADIS16470StatusFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ADIS16470StatusFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ADIS16470StatusFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<ADIS16470StatusFrame> CreateADIS16470StatusFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    double angle = 0.0,
    double rate = 0.0,
    double gyroInstantX = 0.0,
    double gyroInstantY = 0.0,
    double gyroInstantZ = 0.0,
    double accelInstantX = 0.0,
    double accelInstantY = 0.0,
    double accelInstantZ = 0.0,
    double xComplimentaryAngle = 0.0,
    double yComplimentaryAngle = 0.0,
    double xFilteredAccelAngle = 0.0,
    double yFilteredAccelAngle = 0.0,
    uint8_t yawAxis = 0) {
  ADIS16470StatusFrameBuilder builder_(_fbb);
  builder_.add_yFilteredAccelAngle(yFilteredAccelAngle);
  builder_.add_xFilteredAccelAngle(xFilteredAccelAngle);
  builder_.add_yComplimentaryAngle(yComplimentaryAngle);
  builder_.add_xComplimentaryAngle(xComplimentaryAngle);
  builder_.add_accelInstantZ(accelInstantZ);
  builder_.add_accelInstantY(accelInstantY);
  builder_.add_accelInstantX(accelInstantX);
  builder_.add_gyroInstantZ(gyroInstantZ);
  builder_.add_gyroInstantY(gyroInstantY);
  builder_.add_gyroInstantX(gyroInstantX);
  builder_.add_rate(rate);
  builder_.add_angle(angle);
  builder_.add_yawAxis(yawAxis);
  return builder_.Finish();
}

struct CTREMotorStatusFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CTREMotorStatusFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRMWAREVERSION = 4,
    VT_BASEID = 6,
    VT_DEVICEID = 8,
    VT_OUTPUTCURRENT = 10,
    VT_BUSVOLTAGE = 12,
    VT_OUTPUTPERCENT = 14,
    VT_OUTPUTVOLTAGE = 16,
    VT_TEMPERATURE = 18,
    VT_SELECTEDSENSORPOSITION = 20,
    VT_SELECTEDSENSORVELOCITY = 22,
    VT_CLOSEDLOOPERROR = 24,
    VT_INTEGRALACCUMULATOR = 26,
    VT_ERRORDERIVATIVE = 28,
    VT_CLOSEDLOOPTARGET = 30,
    VT_ACTIVETRAJECTORYPOSITION = 32,
    VT_ACTIVETRAJECTORYVELOCITY = 34,
    VT_ACTIVETRAJECTORYARBFEEDFWD = 36,
    VT_FAULTS = 38,
    VT_RESETOCCURED = 40,
    VT_LASTERROR = 42,
    VT_CONTROLMODE = 44,
    VT_STATORCURRENT = 46,
    VT_SUPPLYCURRENT = 48,
    VT_FWDLIMITSWITCHCLOSED = 50,
    VT_REVLIMITSWITCHCLOSED = 52
  };
  int32_t firmwareVersion() const {
    return GetField<int32_t>(VT_FIRMWAREVERSION, 0);
  }
  int32_t baseID() const {
    return GetField<int32_t>(VT_BASEID, 0);
  }
  int32_t deviceID() const {
    return GetField<int32_t>(VT_DEVICEID, 0);
  }
  double outputCurrent() const {
    return GetField<double>(VT_OUTPUTCURRENT, 0.0);
  }
  double busVoltage() const {
    return GetField<double>(VT_BUSVOLTAGE, 0.0);
  }
  double outputPercent() const {
    return GetField<double>(VT_OUTPUTPERCENT, 0.0);
  }
  double outputVoltage() const {
    return GetField<double>(VT_OUTPUTVOLTAGE, 0.0);
  }
  double temperature() const {
    return GetField<double>(VT_TEMPERATURE, 0.0);
  }
  int32_t selectedSensorPosition() const {
    return GetField<int32_t>(VT_SELECTEDSENSORPOSITION, 0);
  }
  int32_t selectedSensorVelocity() const {
    return GetField<int32_t>(VT_SELECTEDSENSORVELOCITY, 0);
  }
  int32_t closedLoopError() const {
    return GetField<int32_t>(VT_CLOSEDLOOPERROR, 0);
  }
  double integralAccumulator() const {
    return GetField<double>(VT_INTEGRALACCUMULATOR, 0.0);
  }
  double errorDerivative() const {
    return GetField<double>(VT_ERRORDERIVATIVE, 0.0);
  }
  double closedLoopTarget() const {
    return GetField<double>(VT_CLOSEDLOOPTARGET, 0.0);
  }
  int32_t activeTrajectoryPosition() const {
    return GetField<int32_t>(VT_ACTIVETRAJECTORYPOSITION, 0);
  }
  int32_t activeTrajectoryVelocity() const {
    return GetField<int32_t>(VT_ACTIVETRAJECTORYVELOCITY, 0);
  }
  double activeTrajectoryArbFeedFwd() const {
    return GetField<double>(VT_ACTIVETRAJECTORYARBFEEDFWD, 0.0);
  }
  int32_t faults() const {
    return GetField<int32_t>(VT_FAULTS, 0);
  }
  bool resetOccured() const {
    return GetField<uint8_t>(VT_RESETOCCURED, 0) != 0;
  }
  int32_t lastError() const {
    return GetField<int32_t>(VT_LASTERROR, 0);
  }
  int32_t controlMode() const {
    return GetField<int32_t>(VT_CONTROLMODE, 0);
  }
  double statorCurrent() const {
    return GetField<double>(VT_STATORCURRENT, 0.0);
  }
  double supplyCurrent() const {
    return GetField<double>(VT_SUPPLYCURRENT, 0.0);
  }
  int32_t fwdLimitSwitchClosed() const {
    return GetField<int32_t>(VT_FWDLIMITSWITCHCLOSED, 0);
  }
  int32_t revLimitSwitchClosed() const {
    return GetField<int32_t>(VT_REVLIMITSWITCHCLOSED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FIRMWAREVERSION) &&
           VerifyField<int32_t>(verifier, VT_BASEID) &&
           VerifyField<int32_t>(verifier, VT_DEVICEID) &&
           VerifyField<double>(verifier, VT_OUTPUTCURRENT) &&
           VerifyField<double>(verifier, VT_BUSVOLTAGE) &&
           VerifyField<double>(verifier, VT_OUTPUTPERCENT) &&
           VerifyField<double>(verifier, VT_OUTPUTVOLTAGE) &&
           VerifyField<double>(verifier, VT_TEMPERATURE) &&
           VerifyField<int32_t>(verifier, VT_SELECTEDSENSORPOSITION) &&
           VerifyField<int32_t>(verifier, VT_SELECTEDSENSORVELOCITY) &&
           VerifyField<int32_t>(verifier, VT_CLOSEDLOOPERROR) &&
           VerifyField<double>(verifier, VT_INTEGRALACCUMULATOR) &&
           VerifyField<double>(verifier, VT_ERRORDERIVATIVE) &&
           VerifyField<double>(verifier, VT_CLOSEDLOOPTARGET) &&
           VerifyField<int32_t>(verifier, VT_ACTIVETRAJECTORYPOSITION) &&
           VerifyField<int32_t>(verifier, VT_ACTIVETRAJECTORYVELOCITY) &&
           VerifyField<double>(verifier, VT_ACTIVETRAJECTORYARBFEEDFWD) &&
           VerifyField<int32_t>(verifier, VT_FAULTS) &&
           VerifyField<uint8_t>(verifier, VT_RESETOCCURED) &&
           VerifyField<int32_t>(verifier, VT_LASTERROR) &&
           VerifyField<int32_t>(verifier, VT_CONTROLMODE) &&
           VerifyField<double>(verifier, VT_STATORCURRENT) &&
           VerifyField<double>(verifier, VT_SUPPLYCURRENT) &&
           VerifyField<int32_t>(verifier, VT_FWDLIMITSWITCHCLOSED) &&
           VerifyField<int32_t>(verifier, VT_REVLIMITSWITCHCLOSED) &&
           verifier.EndTable();
  }
};

struct CTREMotorStatusFrameBuilder {
  typedef CTREMotorStatusFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_firmwareVersion(int32_t firmwareVersion) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_FIRMWAREVERSION, firmwareVersion, 0);
  }
  void add_baseID(int32_t baseID) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_BASEID, baseID, 0);
  }
  void add_deviceID(int32_t deviceID) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_DEVICEID, deviceID, 0);
  }
  void add_outputCurrent(double outputCurrent) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_OUTPUTCURRENT, outputCurrent, 0.0);
  }
  void add_busVoltage(double busVoltage) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_BUSVOLTAGE, busVoltage, 0.0);
  }
  void add_outputPercent(double outputPercent) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_OUTPUTPERCENT, outputPercent, 0.0);
  }
  void add_outputVoltage(double outputVoltage) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_OUTPUTVOLTAGE, outputVoltage, 0.0);
  }
  void add_temperature(double temperature) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_TEMPERATURE, temperature, 0.0);
  }
  void add_selectedSensorPosition(int32_t selectedSensorPosition) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_SELECTEDSENSORPOSITION, selectedSensorPosition, 0);
  }
  void add_selectedSensorVelocity(int32_t selectedSensorVelocity) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_SELECTEDSENSORVELOCITY, selectedSensorVelocity, 0);
  }
  void add_closedLoopError(int32_t closedLoopError) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_CLOSEDLOOPERROR, closedLoopError, 0);
  }
  void add_integralAccumulator(double integralAccumulator) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_INTEGRALACCUMULATOR, integralAccumulator, 0.0);
  }
  void add_errorDerivative(double errorDerivative) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_ERRORDERIVATIVE, errorDerivative, 0.0);
  }
  void add_closedLoopTarget(double closedLoopTarget) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_CLOSEDLOOPTARGET, closedLoopTarget, 0.0);
  }
  void add_activeTrajectoryPosition(int32_t activeTrajectoryPosition) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_ACTIVETRAJECTORYPOSITION, activeTrajectoryPosition, 0);
  }
  void add_activeTrajectoryVelocity(int32_t activeTrajectoryVelocity) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_ACTIVETRAJECTORYVELOCITY, activeTrajectoryVelocity, 0);
  }
  void add_activeTrajectoryArbFeedFwd(double activeTrajectoryArbFeedFwd) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_ACTIVETRAJECTORYARBFEEDFWD, activeTrajectoryArbFeedFwd, 0.0);
  }
  void add_faults(int32_t faults) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_FAULTS, faults, 0);
  }
  void add_resetOccured(bool resetOccured) {
    fbb_.AddElement<uint8_t>(CTREMotorStatusFrame::VT_RESETOCCURED, static_cast<uint8_t>(resetOccured), 0);
  }
  void add_lastError(int32_t lastError) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_LASTERROR, lastError, 0);
  }
  void add_controlMode(int32_t controlMode) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_CONTROLMODE, controlMode, 0);
  }
  void add_statorCurrent(double statorCurrent) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_STATORCURRENT, statorCurrent, 0.0);
  }
  void add_supplyCurrent(double supplyCurrent) {
    fbb_.AddElement<double>(CTREMotorStatusFrame::VT_SUPPLYCURRENT, supplyCurrent, 0.0);
  }
  void add_fwdLimitSwitchClosed(int32_t fwdLimitSwitchClosed) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_FWDLIMITSWITCHCLOSED, fwdLimitSwitchClosed, 0);
  }
  void add_revLimitSwitchClosed(int32_t revLimitSwitchClosed) {
    fbb_.AddElement<int32_t>(CTREMotorStatusFrame::VT_REVLIMITSWITCHCLOSED, revLimitSwitchClosed, 0);
  }
  explicit CTREMotorStatusFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CTREMotorStatusFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CTREMotorStatusFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<CTREMotorStatusFrame> CreateCTREMotorStatusFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t firmwareVersion = 0,
    int32_t baseID = 0,
    int32_t deviceID = 0,
    double outputCurrent = 0.0,
    double busVoltage = 0.0,
    double outputPercent = 0.0,
    double outputVoltage = 0.0,
    double temperature = 0.0,
    int32_t selectedSensorPosition = 0,
    int32_t selectedSensorVelocity = 0,
    int32_t closedLoopError = 0,
    double integralAccumulator = 0.0,
    double errorDerivative = 0.0,
    double closedLoopTarget = 0.0,
    int32_t activeTrajectoryPosition = 0,
    int32_t activeTrajectoryVelocity = 0,
    double activeTrajectoryArbFeedFwd = 0.0,
    int32_t faults = 0,
    bool resetOccured = false,
    int32_t lastError = 0,
    int32_t controlMode = 0,
    double statorCurrent = 0.0,
    double supplyCurrent = 0.0,
    int32_t fwdLimitSwitchClosed = 0,
    int32_t revLimitSwitchClosed = 0) {
  CTREMotorStatusFrameBuilder builder_(_fbb);
  builder_.add_supplyCurrent(supplyCurrent);
  builder_.add_statorCurrent(statorCurrent);
  builder_.add_activeTrajectoryArbFeedFwd(activeTrajectoryArbFeedFwd);
  builder_.add_closedLoopTarget(closedLoopTarget);
  builder_.add_errorDerivative(errorDerivative);
  builder_.add_integralAccumulator(integralAccumulator);
  builder_.add_temperature(temperature);
  builder_.add_outputVoltage(outputVoltage);
  builder_.add_outputPercent(outputPercent);
  builder_.add_busVoltage(busVoltage);
  builder_.add_outputCurrent(outputCurrent);
  builder_.add_revLimitSwitchClosed(revLimitSwitchClosed);
  builder_.add_fwdLimitSwitchClosed(fwdLimitSwitchClosed);
  builder_.add_controlMode(controlMode);
  builder_.add_lastError(lastError);
  builder_.add_faults(faults);
  builder_.add_activeTrajectoryVelocity(activeTrajectoryVelocity);
  builder_.add_activeTrajectoryPosition(activeTrajectoryPosition);
  builder_.add_closedLoopError(closedLoopError);
  builder_.add_selectedSensorVelocity(selectedSensorVelocity);
  builder_.add_selectedSensorPosition(selectedSensorPosition);
  builder_.add_deviceID(deviceID);
  builder_.add_baseID(baseID);
  builder_.add_firmwareVersion(firmwareVersion);
  builder_.add_resetOccured(resetOccured);
  return builder_.Finish();
}

struct PDPStatusFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PDPStatusFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODULE_ = 4,
    VT_VOLTAGE = 6,
    VT_TEMPERATURE = 8,
    VT_CHANNELCURRENT = 10,
    VT_TOTALCURRENT = 12,
    VT_TOTALPOWER = 14,
    VT_TOTALENERGY = 16
  };
  int32_t module_() const {
    return GetField<int32_t>(VT_MODULE_, 0);
  }
  double voltage() const {
    return GetField<double>(VT_VOLTAGE, 0.0);
  }
  double temperature() const {
    return GetField<double>(VT_TEMPERATURE, 0.0);
  }
  const flatbuffers::Vector<double> *channelCurrent() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_CHANNELCURRENT);
  }
  double totalCurrent() const {
    return GetField<double>(VT_TOTALCURRENT, 0.0);
  }
  double totalPower() const {
    return GetField<double>(VT_TOTALPOWER, 0.0);
  }
  double totalEnergy() const {
    return GetField<double>(VT_TOTALENERGY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODULE_) &&
           VerifyField<double>(verifier, VT_VOLTAGE) &&
           VerifyField<double>(verifier, VT_TEMPERATURE) &&
           VerifyOffset(verifier, VT_CHANNELCURRENT) &&
           verifier.VerifyVector(channelCurrent()) &&
           VerifyField<double>(verifier, VT_TOTALCURRENT) &&
           VerifyField<double>(verifier, VT_TOTALPOWER) &&
           VerifyField<double>(verifier, VT_TOTALENERGY) &&
           verifier.EndTable();
  }
};

struct PDPStatusFrameBuilder {
  typedef PDPStatusFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_module_(int32_t module_) {
    fbb_.AddElement<int32_t>(PDPStatusFrame::VT_MODULE_, module_, 0);
  }
  void add_voltage(double voltage) {
    fbb_.AddElement<double>(PDPStatusFrame::VT_VOLTAGE, voltage, 0.0);
  }
  void add_temperature(double temperature) {
    fbb_.AddElement<double>(PDPStatusFrame::VT_TEMPERATURE, temperature, 0.0);
  }
  void add_channelCurrent(flatbuffers::Offset<flatbuffers::Vector<double>> channelCurrent) {
    fbb_.AddOffset(PDPStatusFrame::VT_CHANNELCURRENT, channelCurrent);
  }
  void add_totalCurrent(double totalCurrent) {
    fbb_.AddElement<double>(PDPStatusFrame::VT_TOTALCURRENT, totalCurrent, 0.0);
  }
  void add_totalPower(double totalPower) {
    fbb_.AddElement<double>(PDPStatusFrame::VT_TOTALPOWER, totalPower, 0.0);
  }
  void add_totalEnergy(double totalEnergy) {
    fbb_.AddElement<double>(PDPStatusFrame::VT_TOTALENERGY, totalEnergy, 0.0);
  }
  explicit PDPStatusFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PDPStatusFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PDPStatusFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<PDPStatusFrame> CreatePDPStatusFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t module_ = 0,
    double voltage = 0.0,
    double temperature = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> channelCurrent = 0,
    double totalCurrent = 0.0,
    double totalPower = 0.0,
    double totalEnergy = 0.0) {
  PDPStatusFrameBuilder builder_(_fbb);
  builder_.add_totalEnergy(totalEnergy);
  builder_.add_totalPower(totalPower);
  builder_.add_totalCurrent(totalCurrent);
  builder_.add_temperature(temperature);
  builder_.add_voltage(voltage);
  builder_.add_channelCurrent(channelCurrent);
  builder_.add_module_(module_);
  return builder_.Finish();
}

inline flatbuffers::Offset<PDPStatusFrame> CreatePDPStatusFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t module_ = 0,
    double voltage = 0.0,
    double temperature = 0.0,
    const std::vector<double> *channelCurrent = nullptr,
    double totalCurrent = 0.0,
    double totalPower = 0.0,
    double totalEnergy = 0.0) {
  auto channelCurrent__ = channelCurrent ? _fbb.CreateVector<double>(*channelCurrent) : 0;
  return rj::CreatePDPStatusFrame(
      _fbb,
      module_,
      voltage,
      temperature,
      channelCurrent__,
      totalCurrent,
      totalPower,
      totalEnergy);
}

struct PCMStatusFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PCMStatusFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODULE_ = 4,
    VT_ENABLED = 6,
    VT_PRESSURESWITCHVALVE = 8,
    VT_COMPRESSORCURRENT = 10,
    VT_CLOSEDLOOPCONTROL = 12,
    VT_COMPRESSORCURRENTTOOHIGHFAULT = 14,
    VT_COMPRESSORSHORTEDFAULT = 16,
    VT_COMPRESSORNOTCONNECTEDFAULT = 18
  };
  int32_t module_() const {
    return GetField<int32_t>(VT_MODULE_, 0);
  }
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  bool pressureSwitchValve() const {
    return GetField<uint8_t>(VT_PRESSURESWITCHVALVE, 0) != 0;
  }
  double compressorCurrent() const {
    return GetField<double>(VT_COMPRESSORCURRENT, 0.0);
  }
  bool closedLoopControl() const {
    return GetField<uint8_t>(VT_CLOSEDLOOPCONTROL, 0) != 0;
  }
  bool compressorCurrentTooHighFault() const {
    return GetField<uint8_t>(VT_COMPRESSORCURRENTTOOHIGHFAULT, 0) != 0;
  }
  bool compressorShortedFault() const {
    return GetField<uint8_t>(VT_COMPRESSORSHORTEDFAULT, 0) != 0;
  }
  bool compressorNotConnectedFault() const {
    return GetField<uint8_t>(VT_COMPRESSORNOTCONNECTEDFAULT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODULE_) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<uint8_t>(verifier, VT_PRESSURESWITCHVALVE) &&
           VerifyField<double>(verifier, VT_COMPRESSORCURRENT) &&
           VerifyField<uint8_t>(verifier, VT_CLOSEDLOOPCONTROL) &&
           VerifyField<uint8_t>(verifier, VT_COMPRESSORCURRENTTOOHIGHFAULT) &&
           VerifyField<uint8_t>(verifier, VT_COMPRESSORSHORTEDFAULT) &&
           VerifyField<uint8_t>(verifier, VT_COMPRESSORNOTCONNECTEDFAULT) &&
           verifier.EndTable();
  }
};

struct PCMStatusFrameBuilder {
  typedef PCMStatusFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_module_(int32_t module_) {
    fbb_.AddElement<int32_t>(PCMStatusFrame::VT_MODULE_, module_, 0);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(PCMStatusFrame::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_pressureSwitchValve(bool pressureSwitchValve) {
    fbb_.AddElement<uint8_t>(PCMStatusFrame::VT_PRESSURESWITCHVALVE, static_cast<uint8_t>(pressureSwitchValve), 0);
  }
  void add_compressorCurrent(double compressorCurrent) {
    fbb_.AddElement<double>(PCMStatusFrame::VT_COMPRESSORCURRENT, compressorCurrent, 0.0);
  }
  void add_closedLoopControl(bool closedLoopControl) {
    fbb_.AddElement<uint8_t>(PCMStatusFrame::VT_CLOSEDLOOPCONTROL, static_cast<uint8_t>(closedLoopControl), 0);
  }
  void add_compressorCurrentTooHighFault(bool compressorCurrentTooHighFault) {
    fbb_.AddElement<uint8_t>(PCMStatusFrame::VT_COMPRESSORCURRENTTOOHIGHFAULT, static_cast<uint8_t>(compressorCurrentTooHighFault), 0);
  }
  void add_compressorShortedFault(bool compressorShortedFault) {
    fbb_.AddElement<uint8_t>(PCMStatusFrame::VT_COMPRESSORSHORTEDFAULT, static_cast<uint8_t>(compressorShortedFault), 0);
  }
  void add_compressorNotConnectedFault(bool compressorNotConnectedFault) {
    fbb_.AddElement<uint8_t>(PCMStatusFrame::VT_COMPRESSORNOTCONNECTEDFAULT, static_cast<uint8_t>(compressorNotConnectedFault), 0);
  }
  explicit PCMStatusFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PCMStatusFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PCMStatusFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<PCMStatusFrame> CreatePCMStatusFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t module_ = 0,
    bool enabled = false,
    bool pressureSwitchValve = false,
    double compressorCurrent = 0.0,
    bool closedLoopControl = false,
    bool compressorCurrentTooHighFault = false,
    bool compressorShortedFault = false,
    bool compressorNotConnectedFault = false) {
  PCMStatusFrameBuilder builder_(_fbb);
  builder_.add_compressorCurrent(compressorCurrent);
  builder_.add_module_(module_);
  builder_.add_compressorNotConnectedFault(compressorNotConnectedFault);
  builder_.add_compressorShortedFault(compressorShortedFault);
  builder_.add_compressorCurrentTooHighFault(compressorCurrentTooHighFault);
  builder_.add_closedLoopControl(closedLoopControl);
  builder_.add_pressureSwitchValve(pressureSwitchValve);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

struct WPIDigitalInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WPIDigitalInputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNEL = 4,
    VT_VALUE = 6,
    VT_ISANALOGTRIGGER = 8
  };
  int32_t channel() const {
    return GetField<int32_t>(VT_CHANNEL, 0);
  }
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool isAnalogTrigger() const {
    return GetField<uint8_t>(VT_ISANALOGTRIGGER, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNEL) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           VerifyField<uint8_t>(verifier, VT_ISANALOGTRIGGER) &&
           verifier.EndTable();
  }
};

struct WPIDigitalInputBuilder {
  typedef WPIDigitalInput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(int32_t channel) {
    fbb_.AddElement<int32_t>(WPIDigitalInput::VT_CHANNEL, channel, 0);
  }
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(WPIDigitalInput::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  void add_isAnalogTrigger(bool isAnalogTrigger) {
    fbb_.AddElement<uint8_t>(WPIDigitalInput::VT_ISANALOGTRIGGER, static_cast<uint8_t>(isAnalogTrigger), 0);
  }
  explicit WPIDigitalInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WPIDigitalInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WPIDigitalInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<WPIDigitalInput> CreateWPIDigitalInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channel = 0,
    bool value = false,
    bool isAnalogTrigger = false) {
  WPIDigitalInputBuilder builder_(_fbb);
  builder_.add_channel(channel);
  builder_.add_isAnalogTrigger(isAnalogTrigger);
  builder_.add_value(value);
  return builder_.Finish();
}

struct WPIEncoder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WPIEncoderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_PERIOD = 6,
    VT_STOPPED = 8,
    VT_DIRECTION = 10,
    VT_RAW = 12,
    VT_ENCODINGSCALE = 14,
    VT_DISTANCE = 16,
    VT_RATE = 18,
    VT_DISTANCEPERPULSE = 20,
    VT_SAMPLESTOAVERAGE = 22,
    VT_PIDGET = 24,
    VT_MODULE_ = 26
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  double period() const {
    return GetField<double>(VT_PERIOD, 0.0);
  }
  bool stopped() const {
    return GetField<uint8_t>(VT_STOPPED, 0) != 0;
  }
  bool direction() const {
    return GetField<uint8_t>(VT_DIRECTION, 0) != 0;
  }
  int32_t raw() const {
    return GetField<int32_t>(VT_RAW, 0);
  }
  int32_t encodingScale() const {
    return GetField<int32_t>(VT_ENCODINGSCALE, 0);
  }
  double distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  double rate() const {
    return GetField<double>(VT_RATE, 0.0);
  }
  double distancePerPulse() const {
    return GetField<double>(VT_DISTANCEPERPULSE, 0.0);
  }
  int32_t samplesToAverage() const {
    return GetField<int32_t>(VT_SAMPLESTOAVERAGE, 0);
  }
  double pidGet() const {
    return GetField<double>(VT_PIDGET, 0.0);
  }
  int32_t module_() const {
    return GetField<int32_t>(VT_MODULE_, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           VerifyField<double>(verifier, VT_PERIOD) &&
           VerifyField<uint8_t>(verifier, VT_STOPPED) &&
           VerifyField<uint8_t>(verifier, VT_DIRECTION) &&
           VerifyField<int32_t>(verifier, VT_RAW) &&
           VerifyField<int32_t>(verifier, VT_ENCODINGSCALE) &&
           VerifyField<double>(verifier, VT_DISTANCE) &&
           VerifyField<double>(verifier, VT_RATE) &&
           VerifyField<double>(verifier, VT_DISTANCEPERPULSE) &&
           VerifyField<int32_t>(verifier, VT_SAMPLESTOAVERAGE) &&
           VerifyField<double>(verifier, VT_PIDGET) &&
           VerifyField<int32_t>(verifier, VT_MODULE_) &&
           verifier.EndTable();
  }
};

struct WPIEncoderBuilder {
  typedef WPIEncoder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(WPIEncoder::VT_VALUE, value, 0);
  }
  void add_period(double period) {
    fbb_.AddElement<double>(WPIEncoder::VT_PERIOD, period, 0.0);
  }
  void add_stopped(bool stopped) {
    fbb_.AddElement<uint8_t>(WPIEncoder::VT_STOPPED, static_cast<uint8_t>(stopped), 0);
  }
  void add_direction(bool direction) {
    fbb_.AddElement<uint8_t>(WPIEncoder::VT_DIRECTION, static_cast<uint8_t>(direction), 0);
  }
  void add_raw(int32_t raw) {
    fbb_.AddElement<int32_t>(WPIEncoder::VT_RAW, raw, 0);
  }
  void add_encodingScale(int32_t encodingScale) {
    fbb_.AddElement<int32_t>(WPIEncoder::VT_ENCODINGSCALE, encodingScale, 0);
  }
  void add_distance(double distance) {
    fbb_.AddElement<double>(WPIEncoder::VT_DISTANCE, distance, 0.0);
  }
  void add_rate(double rate) {
    fbb_.AddElement<double>(WPIEncoder::VT_RATE, rate, 0.0);
  }
  void add_distancePerPulse(double distancePerPulse) {
    fbb_.AddElement<double>(WPIEncoder::VT_DISTANCEPERPULSE, distancePerPulse, 0.0);
  }
  void add_samplesToAverage(int32_t samplesToAverage) {
    fbb_.AddElement<int32_t>(WPIEncoder::VT_SAMPLESTOAVERAGE, samplesToAverage, 0);
  }
  void add_pidGet(double pidGet) {
    fbb_.AddElement<double>(WPIEncoder::VT_PIDGET, pidGet, 0.0);
  }
  void add_module_(int32_t module_) {
    fbb_.AddElement<int32_t>(WPIEncoder::VT_MODULE_, module_, 0);
  }
  explicit WPIEncoderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WPIEncoder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WPIEncoder>(end);
    return o;
  }
};

inline flatbuffers::Offset<WPIEncoder> CreateWPIEncoder(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0,
    double period = 0.0,
    bool stopped = false,
    bool direction = false,
    int32_t raw = 0,
    int32_t encodingScale = 0,
    double distance = 0.0,
    double rate = 0.0,
    double distancePerPulse = 0.0,
    int32_t samplesToAverage = 0,
    double pidGet = 0.0,
    int32_t module_ = 0) {
  WPIEncoderBuilder builder_(_fbb);
  builder_.add_pidGet(pidGet);
  builder_.add_distancePerPulse(distancePerPulse);
  builder_.add_rate(rate);
  builder_.add_distance(distance);
  builder_.add_period(period);
  builder_.add_module_(module_);
  builder_.add_samplesToAverage(samplesToAverage);
  builder_.add_encodingScale(encodingScale);
  builder_.add_raw(raw);
  builder_.add_value(value);
  builder_.add_direction(direction);
  builder_.add_stopped(stopped);
  return builder_.Finish();
}

struct WPIDutyCycleEncoder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WPIDutyCycleEncoderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREQUENCY = 4,
    VT_CONNECTED = 6,
    VT_VALUE = 8,
    VT_DISTANCEPERROTATION = 10,
    VT_DISTANCE = 12,
    VT_INDEX = 14,
    VT_SOURCECHANNEL = 16
  };
  int32_t frequency() const {
    return GetField<int32_t>(VT_FREQUENCY, 0);
  }
  bool connected() const {
    return GetField<uint8_t>(VT_CONNECTED, 0) != 0;
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  double distancePerRotation() const {
    return GetField<double>(VT_DISTANCEPERROTATION, 0.0);
  }
  double distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  int32_t sourceChannel() const {
    return GetField<int32_t>(VT_SOURCECHANNEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FREQUENCY) &&
           VerifyField<uint8_t>(verifier, VT_CONNECTED) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           VerifyField<double>(verifier, VT_DISTANCEPERROTATION) &&
           VerifyField<double>(verifier, VT_DISTANCE) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_SOURCECHANNEL) &&
           verifier.EndTable();
  }
};

struct WPIDutyCycleEncoderBuilder {
  typedef WPIDutyCycleEncoder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frequency(int32_t frequency) {
    fbb_.AddElement<int32_t>(WPIDutyCycleEncoder::VT_FREQUENCY, frequency, 0);
  }
  void add_connected(bool connected) {
    fbb_.AddElement<uint8_t>(WPIDutyCycleEncoder::VT_CONNECTED, static_cast<uint8_t>(connected), 0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(WPIDutyCycleEncoder::VT_VALUE, value, 0.0);
  }
  void add_distancePerRotation(double distancePerRotation) {
    fbb_.AddElement<double>(WPIDutyCycleEncoder::VT_DISTANCEPERROTATION, distancePerRotation, 0.0);
  }
  void add_distance(double distance) {
    fbb_.AddElement<double>(WPIDutyCycleEncoder::VT_DISTANCE, distance, 0.0);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(WPIDutyCycleEncoder::VT_INDEX, index, 0);
  }
  void add_sourceChannel(int32_t sourceChannel) {
    fbb_.AddElement<int32_t>(WPIDutyCycleEncoder::VT_SOURCECHANNEL, sourceChannel, 0);
  }
  explicit WPIDutyCycleEncoderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WPIDutyCycleEncoder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WPIDutyCycleEncoder>(end);
    return o;
  }
};

inline flatbuffers::Offset<WPIDutyCycleEncoder> CreateWPIDutyCycleEncoder(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frequency = 0,
    bool connected = false,
    double value = 0.0,
    double distancePerRotation = 0.0,
    double distance = 0.0,
    int32_t index = 0,
    int32_t sourceChannel = 0) {
  WPIDutyCycleEncoderBuilder builder_(_fbb);
  builder_.add_distance(distance);
  builder_.add_distancePerRotation(distancePerRotation);
  builder_.add_value(value);
  builder_.add_sourceChannel(sourceChannel);
  builder_.add_index(index);
  builder_.add_frequency(frequency);
  builder_.add_connected(connected);
  return builder_.Finish();
}

struct StatusFrameHolder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusFrameHolderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIXTIME = 4,
    VT_MONOTONICTIME = 6,
    VT_STATUSFRAME_TYPE = 8,
    VT_STATUSFRAME = 10
  };
  double unixTime() const {
    return GetField<double>(VT_UNIXTIME, 0.0);
  }
  double monotonicTime() const {
    return GetField<double>(VT_MONOTONICTIME, 0.0);
  }
  rj::StatusFrame statusFrame_type() const {
    return static_cast<rj::StatusFrame>(GetField<uint8_t>(VT_STATUSFRAME_TYPE, 0));
  }
  const void *statusFrame() const {
    return GetPointer<const void *>(VT_STATUSFRAME);
  }
  template<typename T> const T *statusFrame_as() const;
  const rj::CTREMotorStatusFrame *statusFrame_as_CTREMotorStatusFrame() const {
    return statusFrame_type() == rj::StatusFrame_CTREMotorStatusFrame ? static_cast<const rj::CTREMotorStatusFrame *>(statusFrame()) : nullptr;
  }
  const rj::PDPStatusFrame *statusFrame_as_PDPStatusFrame() const {
    return statusFrame_type() == rj::StatusFrame_PDPStatusFrame ? static_cast<const rj::PDPStatusFrame *>(statusFrame()) : nullptr;
  }
  const rj::PCMStatusFrame *statusFrame_as_PCMStatusFrame() const {
    return statusFrame_type() == rj::StatusFrame_PCMStatusFrame ? static_cast<const rj::PCMStatusFrame *>(statusFrame()) : nullptr;
  }
  const rj::InitializeStatusFrame *statusFrame_as_InitializeStatusFrame() const {
    return statusFrame_type() == rj::StatusFrame_InitializeStatusFrame ? static_cast<const rj::InitializeStatusFrame *>(statusFrame()) : nullptr;
  }
  const rj::REVMotorStatusFrame *statusFrame_as_REVMotorStatusFrame() const {
    return statusFrame_type() == rj::StatusFrame_REVMotorStatusFrame ? static_cast<const rj::REVMotorStatusFrame *>(statusFrame()) : nullptr;
  }
  const rj::REVColorSensorStatusFrame *statusFrame_as_REVColorSensorStatusFrame() const {
    return statusFrame_type() == rj::StatusFrame_REVColorSensorStatusFrame ? static_cast<const rj::REVColorSensorStatusFrame *>(statusFrame()) : nullptr;
  }
  const rj::NavXStatusFrame *statusFrame_as_NavXStatusFrame() const {
    return statusFrame_type() == rj::StatusFrame_NavXStatusFrame ? static_cast<const rj::NavXStatusFrame *>(statusFrame()) : nullptr;
  }
  const rj::ADIS16470StatusFrame *statusFrame_as_ADIS16470StatusFrame() const {
    return statusFrame_type() == rj::StatusFrame_ADIS16470StatusFrame ? static_cast<const rj::ADIS16470StatusFrame *>(statusFrame()) : nullptr;
  }
  const rj::WPIDigitalInput *statusFrame_as_WPIDigitalInput() const {
    return statusFrame_type() == rj::StatusFrame_WPIDigitalInput ? static_cast<const rj::WPIDigitalInput *>(statusFrame()) : nullptr;
  }
  const rj::WPIEncoder *statusFrame_as_WPIEncoder() const {
    return statusFrame_type() == rj::StatusFrame_WPIEncoder ? static_cast<const rj::WPIEncoder *>(statusFrame()) : nullptr;
  }
  const rj::WPIDutyCycleEncoder *statusFrame_as_WPIDutyCycleEncoder() const {
    return statusFrame_type() == rj::StatusFrame_WPIDutyCycleEncoder ? static_cast<const rj::WPIDutyCycleEncoder *>(statusFrame()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_UNIXTIME) &&
           VerifyField<double>(verifier, VT_MONOTONICTIME) &&
           VerifyField<uint8_t>(verifier, VT_STATUSFRAME_TYPE) &&
           VerifyOffset(verifier, VT_STATUSFRAME) &&
           VerifyStatusFrame(verifier, statusFrame(), statusFrame_type()) &&
           verifier.EndTable();
  }
};

template<> inline const rj::CTREMotorStatusFrame *StatusFrameHolder::statusFrame_as<rj::CTREMotorStatusFrame>() const {
  return statusFrame_as_CTREMotorStatusFrame();
}

template<> inline const rj::PDPStatusFrame *StatusFrameHolder::statusFrame_as<rj::PDPStatusFrame>() const {
  return statusFrame_as_PDPStatusFrame();
}

template<> inline const rj::PCMStatusFrame *StatusFrameHolder::statusFrame_as<rj::PCMStatusFrame>() const {
  return statusFrame_as_PCMStatusFrame();
}

template<> inline const rj::InitializeStatusFrame *StatusFrameHolder::statusFrame_as<rj::InitializeStatusFrame>() const {
  return statusFrame_as_InitializeStatusFrame();
}

template<> inline const rj::REVMotorStatusFrame *StatusFrameHolder::statusFrame_as<rj::REVMotorStatusFrame>() const {
  return statusFrame_as_REVMotorStatusFrame();
}

template<> inline const rj::REVColorSensorStatusFrame *StatusFrameHolder::statusFrame_as<rj::REVColorSensorStatusFrame>() const {
  return statusFrame_as_REVColorSensorStatusFrame();
}

template<> inline const rj::NavXStatusFrame *StatusFrameHolder::statusFrame_as<rj::NavXStatusFrame>() const {
  return statusFrame_as_NavXStatusFrame();
}

template<> inline const rj::ADIS16470StatusFrame *StatusFrameHolder::statusFrame_as<rj::ADIS16470StatusFrame>() const {
  return statusFrame_as_ADIS16470StatusFrame();
}

template<> inline const rj::WPIDigitalInput *StatusFrameHolder::statusFrame_as<rj::WPIDigitalInput>() const {
  return statusFrame_as_WPIDigitalInput();
}

template<> inline const rj::WPIEncoder *StatusFrameHolder::statusFrame_as<rj::WPIEncoder>() const {
  return statusFrame_as_WPIEncoder();
}

template<> inline const rj::WPIDutyCycleEncoder *StatusFrameHolder::statusFrame_as<rj::WPIDutyCycleEncoder>() const {
  return statusFrame_as_WPIDutyCycleEncoder();
}

struct StatusFrameHolderBuilder {
  typedef StatusFrameHolder Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_unixTime(double unixTime) {
    fbb_.AddElement<double>(StatusFrameHolder::VT_UNIXTIME, unixTime, 0.0);
  }
  void add_monotonicTime(double monotonicTime) {
    fbb_.AddElement<double>(StatusFrameHolder::VT_MONOTONICTIME, monotonicTime, 0.0);
  }
  void add_statusFrame_type(rj::StatusFrame statusFrame_type) {
    fbb_.AddElement<uint8_t>(StatusFrameHolder::VT_STATUSFRAME_TYPE, static_cast<uint8_t>(statusFrame_type), 0);
  }
  void add_statusFrame(flatbuffers::Offset<void> statusFrame) {
    fbb_.AddOffset(StatusFrameHolder::VT_STATUSFRAME, statusFrame);
  }
  explicit StatusFrameHolderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusFrameHolder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusFrameHolder>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusFrameHolder> CreateStatusFrameHolder(
    flatbuffers::FlatBufferBuilder &_fbb,
    double unixTime = 0.0,
    double monotonicTime = 0.0,
    rj::StatusFrame statusFrame_type = rj::StatusFrame_NONE,
    flatbuffers::Offset<void> statusFrame = 0) {
  StatusFrameHolderBuilder builder_(_fbb);
  builder_.add_monotonicTime(monotonicTime);
  builder_.add_unixTime(unixTime);
  builder_.add_statusFrame(statusFrame);
  builder_.add_statusFrame_type(statusFrame_type);
  return builder_.Finish();
}

inline bool VerifyStatusFrame(flatbuffers::Verifier &verifier, const void *obj, StatusFrame type) {
  switch (type) {
    case StatusFrame_NONE: {
      return true;
    }
    case StatusFrame_CTREMotorStatusFrame: {
      auto ptr = reinterpret_cast<const rj::CTREMotorStatusFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_PDPStatusFrame: {
      auto ptr = reinterpret_cast<const rj::PDPStatusFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_PCMStatusFrame: {
      auto ptr = reinterpret_cast<const rj::PCMStatusFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_InitializeStatusFrame: {
      auto ptr = reinterpret_cast<const rj::InitializeStatusFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_REVMotorStatusFrame: {
      auto ptr = reinterpret_cast<const rj::REVMotorStatusFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_REVColorSensorStatusFrame: {
      auto ptr = reinterpret_cast<const rj::REVColorSensorStatusFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_NavXStatusFrame: {
      auto ptr = reinterpret_cast<const rj::NavXStatusFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_ADIS16470StatusFrame: {
      auto ptr = reinterpret_cast<const rj::ADIS16470StatusFrame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_WPIDigitalInput: {
      auto ptr = reinterpret_cast<const rj::WPIDigitalInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_WPIEncoder: {
      auto ptr = reinterpret_cast<const rj::WPIEncoder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case StatusFrame_WPIDutyCycleEncoder: {
      auto ptr = reinterpret_cast<const rj::WPIDutyCycleEncoder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyStatusFrameVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyStatusFrame(
        verifier,  values->Get(i), types->GetEnum<StatusFrame>(i))) {
      return false;
    }
  }
  return true;
}

inline const rj::StatusFrameHolder *GetStatusFrameHolder(const void *buf) {
  return flatbuffers::GetRoot<rj::StatusFrameHolder>(buf);
}

inline const rj::StatusFrameHolder *GetSizePrefixedStatusFrameHolder(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<rj::StatusFrameHolder>(buf);
}

inline bool VerifyStatusFrameHolderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rj::StatusFrameHolder>(nullptr);
}

inline bool VerifySizePrefixedStatusFrameHolderBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rj::StatusFrameHolder>(nullptr);
}

inline void FinishStatusFrameHolderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rj::StatusFrameHolder> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStatusFrameHolderBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rj::StatusFrameHolder> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace rj

#endif  // FLATBUFFERS_GENERATED_STATUSFRAME_RJ_H_
